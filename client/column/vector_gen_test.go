// Code generated by go generate; DO NOT EDIT
// This file is generated by go generated

package column

import (
	"fmt"
	"math/rand"
	"testing"
	"time"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/stretchr/testify/assert"
)

func TestColumnBinaryVector(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	columnName := fmt.Sprintf("column_BinaryVector_%d", rand.Int())
	columnLen := 12 + rand.Intn(10)
	dim := ([]int{64, 128, 256, 512})[rand.Intn(4)]

	v := make([][]byte, 0, columnLen)
	dlen := dim
	dlen /= 8

	for i := 0; i < columnLen; i++ {
		entry := make([]byte, dlen)
		v = append(v, entry)
	}
	column := NewColumnBinaryVector(columnName, dim, v)

	t.Run("test meta", func(t *testing.T) {
		ft := entity.FieldTypeBinaryVector
		assert.Equal(t, "BinaryVector", ft.Name())
		assert.Equal(t, "[]byte", ft.String())
		pbName, pbType := ft.PbFieldType()
		assert.Equal(t, "[]byte", pbName)
		assert.Equal(t, "", pbType)
	})

	t.Run("test column attribute", func(t *testing.T) {
		assert.Equal(t, columnName, column.Name())
		assert.Equal(t, entity.FieldTypeBinaryVector, column.Type())
		assert.Equal(t, columnLen, column.Len())
		assert.Equal(t, dim, column.Dim())
		assert.Equal(t, v, column.Data())

		var ev []byte
		err := column.AppendValue(ev)
		assert.Equal(t, columnLen+1, column.Len())
		assert.Nil(t, err)

		err = column.AppendValue(struct{}{})
		assert.Equal(t, columnLen+1, column.Len())
		assert.NotNil(t, err)
	})

	t.Run("test column field data", func(t *testing.T) {
		fd := column.FieldData()
		assert.NotNil(t, fd)
		assert.Equal(t, fd.GetFieldName(), columnName)

		c, err := FieldDataVector(fd)
		assert.NotNil(t, c)
		assert.NoError(t, err)
	})

	t.Run("test column field data error", func(t *testing.T) {
		fd := &schemapb.FieldData{
			Type:      schemapb.DataType_BinaryVector,
			FieldName: columnName,
		}
		_, err := FieldDataVector(fd)
		assert.Error(t, err)
	})
}

func TestColumnFloatVector(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	columnName := fmt.Sprintf("column_FloatVector_%d", rand.Int())
	columnLen := 12 + rand.Intn(10)
	dim := ([]int{64, 128, 256, 512})[rand.Intn(4)]

	v := make([][]float32, 0, columnLen)
	dlen := dim

	for i := 0; i < columnLen; i++ {
		entry := make([]float32, dlen)
		v = append(v, entry)
	}
	column := NewColumnFloatVector(columnName, dim, v)

	t.Run("test meta", func(t *testing.T) {
		ft := entity.FieldTypeFloatVector
		assert.Equal(t, "FloatVector", ft.Name())
		assert.Equal(t, "[]float32", ft.String())
		pbName, pbType := ft.PbFieldType()
		assert.Equal(t, "[]float32", pbName)
		assert.Equal(t, "", pbType)
	})

	t.Run("test column attribute", func(t *testing.T) {
		assert.Equal(t, columnName, column.Name())
		assert.Equal(t, entity.FieldTypeFloatVector, column.Type())
		assert.Equal(t, columnLen, column.Len())
		assert.Equal(t, dim, column.Dim())
		assert.Equal(t, v, column.Data())

		var ev []float32
		err := column.AppendValue(ev)
		assert.Equal(t, columnLen+1, column.Len())
		assert.Nil(t, err)

		err = column.AppendValue(struct{}{})
		assert.Equal(t, columnLen+1, column.Len())
		assert.NotNil(t, err)
	})

	t.Run("test column field data", func(t *testing.T) {
		fd := column.FieldData()
		assert.NotNil(t, fd)
		assert.Equal(t, fd.GetFieldName(), columnName)

		c, err := FieldDataVector(fd)
		assert.NotNil(t, c)
		assert.NoError(t, err)
	})

	t.Run("test column field data error", func(t *testing.T) {
		fd := &schemapb.FieldData{
			Type:      schemapb.DataType_FloatVector,
			FieldName: columnName,
		}
		_, err := FieldDataVector(fd)
		assert.Error(t, err)
	})
}

func TestColumnFloat16Vector(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	columnName := fmt.Sprintf("column_Float16Vector_%d", rand.Int())
	columnLen := 12 + rand.Intn(10)
	dim := ([]int{64, 128, 256, 512})[rand.Intn(4)]

	v := make([][]byte, 0, columnLen)
	dlen := dim

	dlen *= 2

	for i := 0; i < columnLen; i++ {
		entry := make([]byte, dlen)
		v = append(v, entry)
	}
	column := NewColumnFloat16Vector(columnName, dim, v)

	t.Run("test meta", func(t *testing.T) {
		ft := entity.FieldTypeFloat16Vector
		assert.Equal(t, "Float16Vector", ft.Name())
		assert.Equal(t, "[]byte", ft.String())
		pbName, pbType := ft.PbFieldType()
		assert.Equal(t, "[]byte", pbName)
		assert.Equal(t, "", pbType)
	})

	t.Run("test column attribute", func(t *testing.T) {
		assert.Equal(t, columnName, column.Name())
		assert.Equal(t, entity.FieldTypeFloat16Vector, column.Type())
		assert.Equal(t, columnLen, column.Len())
		assert.Equal(t, dim, column.Dim())
		assert.Equal(t, v, column.Data())

		var ev []byte
		err := column.AppendValue(ev)
		assert.Equal(t, columnLen+1, column.Len())
		assert.Nil(t, err)

		err = column.AppendValue(struct{}{})
		assert.Equal(t, columnLen+1, column.Len())
		assert.NotNil(t, err)
	})

	t.Run("test column field data", func(t *testing.T) {
		fd := column.FieldData()
		assert.NotNil(t, fd)
		assert.Equal(t, fd.GetFieldName(), columnName)

		c, err := FieldDataVector(fd)
		assert.NotNil(t, c)
		assert.NoError(t, err)
	})

	t.Run("test column field data error", func(t *testing.T) {
		fd := &schemapb.FieldData{
			Type:      schemapb.DataType_Float16Vector,
			FieldName: columnName,
		}
		_, err := FieldDataVector(fd)
		assert.Error(t, err)
	})
}

func TestColumnBFloat16Vector(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	columnName := fmt.Sprintf("column_BFloat16Vector_%d", rand.Int())
	columnLen := 12 + rand.Intn(10)
	dim := ([]int{64, 128, 256, 512})[rand.Intn(4)]

	v := make([][]byte, 0, columnLen)
	dlen := dim

	dlen *= 2

	for i := 0; i < columnLen; i++ {
		entry := make([]byte, dlen)
		v = append(v, entry)
	}
	column := NewColumnBFloat16Vector(columnName, dim, v)

	t.Run("test meta", func(t *testing.T) {
		ft := entity.FieldTypeBFloat16Vector
		assert.Equal(t, "BFloat16Vector", ft.Name())
		assert.Equal(t, "[]byte", ft.String())
		pbName, pbType := ft.PbFieldType()
		assert.Equal(t, "[]byte", pbName)
		assert.Equal(t, "", pbType)
	})

	t.Run("test column attribute", func(t *testing.T) {
		assert.Equal(t, columnName, column.Name())
		assert.Equal(t, entity.FieldTypeBFloat16Vector, column.Type())
		assert.Equal(t, columnLen, column.Len())
		assert.Equal(t, dim, column.Dim())
		assert.Equal(t, v, column.Data())

		var ev []byte
		err := column.AppendValue(ev)
		assert.Equal(t, columnLen+1, column.Len())
		assert.Nil(t, err)

		err = column.AppendValue(struct{}{})
		assert.Equal(t, columnLen+1, column.Len())
		assert.NotNil(t, err)
	})

	t.Run("test column field data", func(t *testing.T) {
		fd := column.FieldData()
		assert.NotNil(t, fd)
		assert.Equal(t, fd.GetFieldName(), columnName)

		c, err := FieldDataVector(fd)
		assert.NotNil(t, c)
		assert.NoError(t, err)
	})

	t.Run("test column field data error", func(t *testing.T) {
		fd := &schemapb.FieldData{
			Type:      schemapb.DataType_BFloat16Vector,
			FieldName: columnName,
		}
		_, err := FieldDataVector(fd)
		assert.Error(t, err)
	})
}
