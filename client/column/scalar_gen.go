// Code generated by go generate; DO NOT EDIT
// This file is generated by go generate

package column

import (
	"errors"
	"fmt"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

// ColumnBool generated columns type for Bool
type ColumnBool struct {
	ColumnBase
	name   string
	values []bool
}

// Name returns column name
func (c *ColumnBool) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnBool) Type() entity.FieldType {
	return entity.FieldTypeBool
}

// Len returns column values length
func (c *ColumnBool) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnBool) Get(idx int) (interface{}, error) {
	var r bool // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnBool) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Bool,
		FieldName: c.name,
	}
	data := make([]bool, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, bool(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_BoolData{
				BoolData: &schemapb.BoolArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnBool) ValueByIdx(idx int) (bool, error) {
	var r bool // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnBool) AppendValue(i interface{}) error {
	v, ok := i.(bool)
	if !ok {
		return fmt.Errorf("invalid type, expected bool, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnBool) Data() []bool {
	return c.values
}

// NewColumnBool auto generated constructor
func NewColumnBool(name string, values []bool) *ColumnBool {
	return &ColumnBool{
		name:   name,
		values: values,
	}
}

// ColumnInt8 generated columns type for Int8
type ColumnInt8 struct {
	ColumnBase
	name   string
	values []int8
}

// Name returns column name
func (c *ColumnInt8) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnInt8) Type() entity.FieldType {
	return entity.FieldTypeInt8
}

// Len returns column values length
func (c *ColumnInt8) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnInt8) Get(idx int) (interface{}, error) {
	var r int8 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnInt8) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Int8,
		FieldName: c.name,
	}
	data := make([]int32, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, int32(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_IntData{
				IntData: &schemapb.IntArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnInt8) ValueByIdx(idx int) (int8, error) {
	var r int8 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnInt8) AppendValue(i interface{}) error {
	v, ok := i.(int8)
	if !ok {
		return fmt.Errorf("invalid type, expected int8, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnInt8) Data() []int8 {
	return c.values
}

// NewColumnInt8 auto generated constructor
func NewColumnInt8(name string, values []int8) *ColumnInt8 {
	return &ColumnInt8{
		name:   name,
		values: values,
	}
}

// ColumnInt16 generated columns type for Int16
type ColumnInt16 struct {
	ColumnBase
	name   string
	values []int16
}

// Name returns column name
func (c *ColumnInt16) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnInt16) Type() entity.FieldType {
	return entity.FieldTypeInt16
}

// Len returns column values length
func (c *ColumnInt16) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnInt16) Get(idx int) (interface{}, error) {
	var r int16 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnInt16) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Int16,
		FieldName: c.name,
	}
	data := make([]int32, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, int32(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_IntData{
				IntData: &schemapb.IntArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnInt16) ValueByIdx(idx int) (int16, error) {
	var r int16 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnInt16) AppendValue(i interface{}) error {
	v, ok := i.(int16)
	if !ok {
		return fmt.Errorf("invalid type, expected int16, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnInt16) Data() []int16 {
	return c.values
}

// NewColumnInt16 auto generated constructor
func NewColumnInt16(name string, values []int16) *ColumnInt16 {
	return &ColumnInt16{
		name:   name,
		values: values,
	}
}

// ColumnInt32 generated columns type for Int32
type ColumnInt32 struct {
	ColumnBase
	name   string
	values []int32
}

// Name returns column name
func (c *ColumnInt32) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnInt32) Type() entity.FieldType {
	return entity.FieldTypeInt32
}

// Len returns column values length
func (c *ColumnInt32) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnInt32) Get(idx int) (interface{}, error) {
	var r int32 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnInt32) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Int32,
		FieldName: c.name,
	}
	data := make([]int32, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, int32(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_IntData{
				IntData: &schemapb.IntArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnInt32) ValueByIdx(idx int) (int32, error) {
	var r int32 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnInt32) AppendValue(i interface{}) error {
	v, ok := i.(int32)
	if !ok {
		return fmt.Errorf("invalid type, expected int32, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnInt32) Data() []int32 {
	return c.values
}

// NewColumnInt32 auto generated constructor
func NewColumnInt32(name string, values []int32) *ColumnInt32 {
	return &ColumnInt32{
		name:   name,
		values: values,
	}
}

// ColumnInt64 generated columns type for Int64
type ColumnInt64 struct {
	ColumnBase
	name   string
	values []int64
}

// Name returns column name
func (c *ColumnInt64) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnInt64) Type() entity.FieldType {
	return entity.FieldTypeInt64
}

// Len returns column values length
func (c *ColumnInt64) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnInt64) Get(idx int) (interface{}, error) {
	var r int64 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnInt64) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Int64,
		FieldName: c.name,
	}
	data := make([]int64, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, int64(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_LongData{
				LongData: &schemapb.LongArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnInt64) ValueByIdx(idx int) (int64, error) {
	var r int64 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnInt64) AppendValue(i interface{}) error {
	v, ok := i.(int64)
	if !ok {
		return fmt.Errorf("invalid type, expected int64, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnInt64) Data() []int64 {
	return c.values
}

// NewColumnInt64 auto generated constructor
func NewColumnInt64(name string, values []int64) *ColumnInt64 {
	return &ColumnInt64{
		name:   name,
		values: values,
	}
}

// ColumnFloat generated columns type for Float
type ColumnFloat struct {
	ColumnBase
	name   string
	values []float32
}

// Name returns column name
func (c *ColumnFloat) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnFloat) Type() entity.FieldType {
	return entity.FieldTypeFloat
}

// Len returns column values length
func (c *ColumnFloat) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnFloat) Get(idx int) (interface{}, error) {
	var r float32 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnFloat) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Float,
		FieldName: c.name,
	}
	data := make([]float32, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, float32(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_FloatData{
				FloatData: &schemapb.FloatArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnFloat) ValueByIdx(idx int) (float32, error) {
	var r float32 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnFloat) AppendValue(i interface{}) error {
	v, ok := i.(float32)
	if !ok {
		return fmt.Errorf("invalid type, expected float32, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnFloat) Data() []float32 {
	return c.values
}

// NewColumnFloat auto generated constructor
func NewColumnFloat(name string, values []float32) *ColumnFloat {
	return &ColumnFloat{
		name:   name,
		values: values,
	}
}

// ColumnDouble generated columns type for Double
type ColumnDouble struct {
	ColumnBase
	name   string
	values []float64
}

// Name returns column name
func (c *ColumnDouble) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnDouble) Type() entity.FieldType {
	return entity.FieldTypeDouble
}

// Len returns column values length
func (c *ColumnDouble) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnDouble) Get(idx int) (interface{}, error) {
	var r float64 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnDouble) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Double,
		FieldName: c.name,
	}
	data := make([]float64, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, float64(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_DoubleData{
				DoubleData: &schemapb.DoubleArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnDouble) ValueByIdx(idx int) (float64, error) {
	var r float64 // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnDouble) AppendValue(i interface{}) error {
	v, ok := i.(float64)
	if !ok {
		return fmt.Errorf("invalid type, expected float64, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnDouble) Data() []float64 {
	return c.values
}

// NewColumnDouble auto generated constructor
func NewColumnDouble(name string, values []float64) *ColumnDouble {
	return &ColumnDouble{
		name:   name,
		values: values,
	}
}

// ColumnString generated columns type for String
type ColumnString struct {
	ColumnBase
	name   string
	values []string
}

// Name returns column name
func (c *ColumnString) Name() string {
	return c.name
}

// Type returns column entity.FieldType
func (c *ColumnString) Type() entity.FieldType {
	return entity.FieldTypeString
}

// Len returns column values length
func (c *ColumnString) Len() int {
	return len(c.values)
}

// Get returns value at index as interface{}.
func (c *ColumnString) Get(idx int) (interface{}, error) {
	var r string // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *ColumnString) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_String,
		FieldName: c.name,
	}
	data := make([]string, 0, c.Len())
	for i := 0; i < c.Len(); i++ {
		data = append(data, string(c.values[i]))
	}
	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_StringData{
				StringData: &schemapb.StringArray{
					Data: data,
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *ColumnString) ValueByIdx(idx int) (string, error) {
	var r string // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func (c *ColumnString) AppendValue(i interface{}) error {
	v, ok := i.(string)
	if !ok {
		return fmt.Errorf("invalid type, expected string, got %T", i)
	}
	c.values = append(c.values, v)

	return nil
}

// Data returns column data
func (c *ColumnString) Data() []string {
	return c.values
}

// NewColumnString auto generated constructor
func NewColumnString(name string, values []string) *ColumnString {
	return &ColumnString{
		name:   name,
		values: values,
	}
}
