/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef OptionalRequiredTest_TYPES_H
#define OptionalRequiredTest_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace thrift { namespace test {

class OldSchool;

class Simple;

class Tricky1;

class Tricky2;

class Tricky3;

class OptionalDefault;

class Complex;

class ManyOpt;

class JavaTestHelper;

class Binaries;

typedef struct _OldSchool__isset {
  _OldSchool__isset() : im_int(false), im_str(false), im_big(false) {}
  bool im_int :1;
  bool im_str :1;
  bool im_big :1;
} _OldSchool__isset;

class OldSchool : public virtual ::apache::thrift::TBase {
 public:

  OldSchool(const OldSchool&);
  OldSchool& operator=(const OldSchool&);
  OldSchool() : im_int(0), im_str() {
  }

  virtual ~OldSchool() throw();
  int16_t im_int;
  std::string im_str;
  std::vector<std::map<int32_t, std::string> >  im_big;

  _OldSchool__isset __isset;

  void __set_im_int(const int16_t val);

  void __set_im_str(const std::string& val);

  void __set_im_big(const std::vector<std::map<int32_t, std::string> > & val);

  bool operator == (const OldSchool & rhs) const
  {
    if (!(im_int == rhs.im_int))
      return false;
    if (!(im_str == rhs.im_str))
      return false;
    if (!(im_big == rhs.im_big))
      return false;
    return true;
  }
  bool operator != (const OldSchool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OldSchool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OldSchool &a, OldSchool &b);

std::ostream& operator<<(std::ostream& out, const OldSchool& obj);

typedef struct _Simple__isset {
  _Simple__isset() : im_default(false), im_optional(false) {}
  bool im_default :1;
  bool im_optional :1;
} _Simple__isset;

class Simple : public virtual ::apache::thrift::TBase {
 public:

  Simple(const Simple&);
  Simple& operator=(const Simple&);
  Simple() : im_default(0), im_required(0), im_optional(0) {
  }

  virtual ~Simple() throw();
  int16_t im_default;
  int16_t im_required;
  int16_t im_optional;

  _Simple__isset __isset;

  void __set_im_default(const int16_t val);

  void __set_im_required(const int16_t val);

  void __set_im_optional(const int16_t val);

  bool operator == (const Simple & rhs) const
  {
    if (!(im_default == rhs.im_default))
      return false;
    if (!(im_required == rhs.im_required))
      return false;
    if (__isset.im_optional != rhs.__isset.im_optional)
      return false;
    else if (__isset.im_optional && !(im_optional == rhs.im_optional))
      return false;
    return true;
  }
  bool operator != (const Simple &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simple & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Simple &a, Simple &b);

std::ostream& operator<<(std::ostream& out, const Simple& obj);

typedef struct _Tricky1__isset {
  _Tricky1__isset() : im_default(false) {}
  bool im_default :1;
} _Tricky1__isset;

class Tricky1 : public virtual ::apache::thrift::TBase {
 public:

  Tricky1(const Tricky1&);
  Tricky1& operator=(const Tricky1&);
  Tricky1() : im_default(0) {
  }

  virtual ~Tricky1() throw();
  int16_t im_default;

  _Tricky1__isset __isset;

  void __set_im_default(const int16_t val);

  bool operator == (const Tricky1 & rhs) const
  {
    if (!(im_default == rhs.im_default))
      return false;
    return true;
  }
  bool operator != (const Tricky1 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Tricky1 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Tricky1 &a, Tricky1 &b);

std::ostream& operator<<(std::ostream& out, const Tricky1& obj);

typedef struct _Tricky2__isset {
  _Tricky2__isset() : im_optional(false) {}
  bool im_optional :1;
} _Tricky2__isset;

class Tricky2 : public virtual ::apache::thrift::TBase {
 public:

  Tricky2(const Tricky2&);
  Tricky2& operator=(const Tricky2&);
  Tricky2() : im_optional(0) {
  }

  virtual ~Tricky2() throw();
  int16_t im_optional;

  _Tricky2__isset __isset;

  void __set_im_optional(const int16_t val);

  bool operator == (const Tricky2 & rhs) const
  {
    if (__isset.im_optional != rhs.__isset.im_optional)
      return false;
    else if (__isset.im_optional && !(im_optional == rhs.im_optional))
      return false;
    return true;
  }
  bool operator != (const Tricky2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Tricky2 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Tricky2 &a, Tricky2 &b);

std::ostream& operator<<(std::ostream& out, const Tricky2& obj);


class Tricky3 : public virtual ::apache::thrift::TBase {
 public:

  Tricky3(const Tricky3&);
  Tricky3& operator=(const Tricky3&);
  Tricky3() : im_required(0) {
  }

  virtual ~Tricky3() throw();
  int16_t im_required;

  void __set_im_required(const int16_t val);

  bool operator == (const Tricky3 & rhs) const
  {
    if (!(im_required == rhs.im_required))
      return false;
    return true;
  }
  bool operator != (const Tricky3 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Tricky3 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Tricky3 &a, Tricky3 &b);

std::ostream& operator<<(std::ostream& out, const Tricky3& obj);

typedef struct _OptionalDefault__isset {
  _OptionalDefault__isset() : opt_int(true), opt_str(true) {}
  bool opt_int :1;
  bool opt_str :1;
} _OptionalDefault__isset;

class OptionalDefault : public virtual ::apache::thrift::TBase {
 public:

  OptionalDefault(const OptionalDefault&);
  OptionalDefault& operator=(const OptionalDefault&);
  OptionalDefault() : opt_int(1234), opt_str("default") {
  }

  virtual ~OptionalDefault() throw();
  int16_t opt_int;
  std::string opt_str;

  _OptionalDefault__isset __isset;

  void __set_opt_int(const int16_t val);

  void __set_opt_str(const std::string& val);

  bool operator == (const OptionalDefault & rhs) const
  {
    if (__isset.opt_int != rhs.__isset.opt_int)
      return false;
    else if (__isset.opt_int && !(opt_int == rhs.opt_int))
      return false;
    if (__isset.opt_str != rhs.__isset.opt_str)
      return false;
    else if (__isset.opt_str && !(opt_str == rhs.opt_str))
      return false;
    return true;
  }
  bool operator != (const OptionalDefault &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OptionalDefault & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OptionalDefault &a, OptionalDefault &b);

std::ostream& operator<<(std::ostream& out, const OptionalDefault& obj);

typedef struct _Complex__isset {
  _Complex__isset() : cp_default(false), cp_optional(false), the_map(false), opt_simp(false) {}
  bool cp_default :1;
  bool cp_optional :1;
  bool the_map :1;
  bool opt_simp :1;
} _Complex__isset;

class Complex : public virtual ::apache::thrift::TBase {
 public:

  Complex(const Complex&);
  Complex& operator=(const Complex&);
  Complex() : cp_default(0), cp_required(0), cp_optional(0) {
  }

  virtual ~Complex() throw();
  int16_t cp_default;
  int16_t cp_required;
  int16_t cp_optional;
  std::map<int16_t, Simple>  the_map;
  Simple req_simp;
  Simple opt_simp;

  _Complex__isset __isset;

  void __set_cp_default(const int16_t val);

  void __set_cp_required(const int16_t val);

  void __set_cp_optional(const int16_t val);

  void __set_the_map(const std::map<int16_t, Simple> & val);

  void __set_req_simp(const Simple& val);

  void __set_opt_simp(const Simple& val);

  bool operator == (const Complex & rhs) const
  {
    if (!(cp_default == rhs.cp_default))
      return false;
    if (!(cp_required == rhs.cp_required))
      return false;
    if (__isset.cp_optional != rhs.__isset.cp_optional)
      return false;
    else if (__isset.cp_optional && !(cp_optional == rhs.cp_optional))
      return false;
    if (!(the_map == rhs.the_map))
      return false;
    if (!(req_simp == rhs.req_simp))
      return false;
    if (__isset.opt_simp != rhs.__isset.opt_simp)
      return false;
    else if (__isset.opt_simp && !(opt_simp == rhs.opt_simp))
      return false;
    return true;
  }
  bool operator != (const Complex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Complex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Complex &a, Complex &b);

std::ostream& operator<<(std::ostream& out, const Complex& obj);

typedef struct _ManyOpt__isset {
  _ManyOpt__isset() : opt1(false), opt2(false), opt3(false), def4(false), opt5(false), opt6(false) {}
  bool opt1 :1;
  bool opt2 :1;
  bool opt3 :1;
  bool def4 :1;
  bool opt5 :1;
  bool opt6 :1;
} _ManyOpt__isset;

class ManyOpt : public virtual ::apache::thrift::TBase {
 public:

  ManyOpt(const ManyOpt&);
  ManyOpt& operator=(const ManyOpt&);
  ManyOpt() : opt1(0), opt2(0), opt3(0), def4(0), opt5(0), opt6(0) {
  }

  virtual ~ManyOpt() throw();
  int32_t opt1;
  int32_t opt2;
  int32_t opt3;
  int32_t def4;
  int32_t opt5;
  int32_t opt6;

  _ManyOpt__isset __isset;

  void __set_opt1(const int32_t val);

  void __set_opt2(const int32_t val);

  void __set_opt3(const int32_t val);

  void __set_def4(const int32_t val);

  void __set_opt5(const int32_t val);

  void __set_opt6(const int32_t val);

  bool operator == (const ManyOpt & rhs) const
  {
    if (__isset.opt1 != rhs.__isset.opt1)
      return false;
    else if (__isset.opt1 && !(opt1 == rhs.opt1))
      return false;
    if (__isset.opt2 != rhs.__isset.opt2)
      return false;
    else if (__isset.opt2 && !(opt2 == rhs.opt2))
      return false;
    if (__isset.opt3 != rhs.__isset.opt3)
      return false;
    else if (__isset.opt3 && !(opt3 == rhs.opt3))
      return false;
    if (!(def4 == rhs.def4))
      return false;
    if (__isset.opt5 != rhs.__isset.opt5)
      return false;
    else if (__isset.opt5 && !(opt5 == rhs.opt5))
      return false;
    if (__isset.opt6 != rhs.__isset.opt6)
      return false;
    else if (__isset.opt6 && !(opt6 == rhs.opt6))
      return false;
    return true;
  }
  bool operator != (const ManyOpt &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ManyOpt & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ManyOpt &a, ManyOpt &b);

std::ostream& operator<<(std::ostream& out, const ManyOpt& obj);

typedef struct _JavaTestHelper__isset {
  _JavaTestHelper__isset() : opt_int(false), opt_obj(false), opt_bin(false) {}
  bool opt_int :1;
  bool opt_obj :1;
  bool opt_bin :1;
} _JavaTestHelper__isset;

class JavaTestHelper : public virtual ::apache::thrift::TBase {
 public:

  JavaTestHelper(const JavaTestHelper&);
  JavaTestHelper& operator=(const JavaTestHelper&);
  JavaTestHelper() : req_int(0), opt_int(0), req_obj(), opt_obj(), req_bin(), opt_bin() {
  }

  virtual ~JavaTestHelper() throw();
  int32_t req_int;
  int32_t opt_int;
  std::string req_obj;
  std::string opt_obj;
  std::string req_bin;
  std::string opt_bin;

  _JavaTestHelper__isset __isset;

  void __set_req_int(const int32_t val);

  void __set_opt_int(const int32_t val);

  void __set_req_obj(const std::string& val);

  void __set_opt_obj(const std::string& val);

  void __set_req_bin(const std::string& val);

  void __set_opt_bin(const std::string& val);

  bool operator == (const JavaTestHelper & rhs) const
  {
    if (!(req_int == rhs.req_int))
      return false;
    if (__isset.opt_int != rhs.__isset.opt_int)
      return false;
    else if (__isset.opt_int && !(opt_int == rhs.opt_int))
      return false;
    if (!(req_obj == rhs.req_obj))
      return false;
    if (__isset.opt_obj != rhs.__isset.opt_obj)
      return false;
    else if (__isset.opt_obj && !(opt_obj == rhs.opt_obj))
      return false;
    if (!(req_bin == rhs.req_bin))
      return false;
    if (__isset.opt_bin != rhs.__isset.opt_bin)
      return false;
    else if (__isset.opt_bin && !(opt_bin == rhs.opt_bin))
      return false;
    return true;
  }
  bool operator != (const JavaTestHelper &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JavaTestHelper & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(JavaTestHelper &a, JavaTestHelper &b);

std::ostream& operator<<(std::ostream& out, const JavaTestHelper& obj);

typedef struct _Binaries__isset {
  _Binaries__isset() : bin(false), opt_bin(false) {}
  bool bin :1;
  bool opt_bin :1;
} _Binaries__isset;

class Binaries : public virtual ::apache::thrift::TBase {
 public:

  Binaries(const Binaries&);
  Binaries& operator=(const Binaries&);
  Binaries() : bin(), req_bin(), opt_bin() {
  }

  virtual ~Binaries() throw();
  std::string bin;
  std::string req_bin;
  std::string opt_bin;

  _Binaries__isset __isset;

  void __set_bin(const std::string& val);

  void __set_req_bin(const std::string& val);

  void __set_opt_bin(const std::string& val);

  bool operator == (const Binaries & rhs) const
  {
    if (!(bin == rhs.bin))
      return false;
    if (!(req_bin == rhs.req_bin))
      return false;
    if (__isset.opt_bin != rhs.__isset.opt_bin)
      return false;
    else if (__isset.opt_bin && !(opt_bin == rhs.opt_bin))
      return false;
    return true;
  }
  bool operator != (const Binaries &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Binaries & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Binaries &a, Binaries &b);

std::ostream& operator<<(std::ostream& out, const Binaries& obj);

}} // namespace

#endif
