/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DebugProtoTest_TYPES_H
#define DebugProtoTest_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace thrift { namespace test { namespace debug {

struct SomeEnum {
  enum type {
    ONE = 1,
    TWO = 2
  };
};

extern const std::map<int, const char*> _SomeEnum_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SomeEnum::type& val);

typedef std::map<int32_t, int32_t>  SomeMap;

class Doubles;

class OneOfEach;

class Bonk;

class Nesting;

class HolyMoley;

class Backwards;

class Empty;

class Wrapper;

class RandomStuff;

class Base64;

class CompactProtoTestStruct;

class SingleMapTestStruct;

class ExceptionWithAMap;

class BlowUp;

class ReverseOrderStruct;

class StructWithSomeEnum;

class TestUnion;

class TestUnionMinusStringField;

class ComparableUnion;

class StructWithAUnion;

class PrimitiveThenStruct;

class StructWithASomemap;

class BigFieldIdStruct;

class BreaksRubyCompactProtocol;

class TupleProtocolTestStruct;

class ListDoublePerf;

typedef struct _Doubles__isset {
  _Doubles__isset() : nan(false), inf(false), neginf(false), repeating(false), big(false), tiny(false), zero(false), negzero(false) {}
  bool nan :1;
  bool inf :1;
  bool neginf :1;
  bool repeating :1;
  bool big :1;
  bool tiny :1;
  bool zero :1;
  bool negzero :1;
} _Doubles__isset;

class Doubles : public virtual ::apache::thrift::TBase {
 public:

  Doubles(const Doubles&);
  Doubles& operator=(const Doubles&);
  Doubles() : nan(0), inf(0), neginf(0), repeating(0), big(0), tiny(0), zero(0), negzero(0) {
  }

  virtual ~Doubles() throw();
  double nan;
  double inf;
  double neginf;
  double repeating;
  double big;
  double tiny;
  double zero;
  double negzero;

  _Doubles__isset __isset;

  void __set_nan(const double val);

  void __set_inf(const double val);

  void __set_neginf(const double val);

  void __set_repeating(const double val);

  void __set_big(const double val);

  void __set_tiny(const double val);

  void __set_zero(const double val);

  void __set_negzero(const double val);

  bool operator == (const Doubles & rhs) const
  {
    if (!(nan == rhs.nan))
      return false;
    if (!(inf == rhs.inf))
      return false;
    if (!(neginf == rhs.neginf))
      return false;
    if (!(repeating == rhs.repeating))
      return false;
    if (!(big == rhs.big))
      return false;
    if (!(tiny == rhs.tiny))
      return false;
    if (!(zero == rhs.zero))
      return false;
    if (!(negzero == rhs.negzero))
      return false;
    return true;
  }
  bool operator != (const Doubles &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Doubles & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Doubles &a, Doubles &b);

std::ostream& operator<<(std::ostream& out, const Doubles& obj);

typedef struct _OneOfEach__isset {
  _OneOfEach__isset() : im_true(false), im_false(false), a_bite(true), integer16(true), integer32(false), integer64(true), double_precision(false), some_characters(false), zomg_unicode(false), what_who(false), base64(false), byte_list(true), i16_list(true), i64_list(true) {}
  bool im_true :1;
  bool im_false :1;
  bool a_bite :1;
  bool integer16 :1;
  bool integer32 :1;
  bool integer64 :1;
  bool double_precision :1;
  bool some_characters :1;
  bool zomg_unicode :1;
  bool what_who :1;
  bool base64 :1;
  bool byte_list :1;
  bool i16_list :1;
  bool i64_list :1;
} _OneOfEach__isset;

class OneOfEach : public virtual ::apache::thrift::TBase {
 public:

  OneOfEach(const OneOfEach&);
  OneOfEach& operator=(const OneOfEach&);
  OneOfEach() : im_true(0), im_false(0), a_bite(127), integer16(32767), integer32(0), integer64(10000000000LL), double_precision(0), some_characters(), zomg_unicode(), what_who(0), base64() {
    byte_list.push_back(1);
    byte_list.push_back(2);
    byte_list.push_back(3);

    i16_list.push_back(1);
    i16_list.push_back(2);
    i16_list.push_back(3);

    i64_list.push_back(1LL);
    i64_list.push_back(2LL);
    i64_list.push_back(3LL);

  }

  virtual ~OneOfEach() throw();
  bool im_true;
  bool im_false;
  int8_t a_bite;
  int16_t integer16;
  int32_t integer32;
  int64_t integer64;
  double double_precision;
  std::string some_characters;
  std::string zomg_unicode;
  bool what_who;
  std::string base64;
  std::vector<int8_t>  byte_list;
  std::vector<int16_t>  i16_list;
  std::vector<int64_t>  i64_list;

  _OneOfEach__isset __isset;

  void __set_im_true(const bool val);

  void __set_im_false(const bool val);

  void __set_a_bite(const int8_t val);

  void __set_integer16(const int16_t val);

  void __set_integer32(const int32_t val);

  void __set_integer64(const int64_t val);

  void __set_double_precision(const double val);

  void __set_some_characters(const std::string& val);

  void __set_zomg_unicode(const std::string& val);

  void __set_what_who(const bool val);

  void __set_base64(const std::string& val);

  void __set_byte_list(const std::vector<int8_t> & val);

  void __set_i16_list(const std::vector<int16_t> & val);

  void __set_i64_list(const std::vector<int64_t> & val);

  bool operator == (const OneOfEach & rhs) const
  {
    if (!(im_true == rhs.im_true))
      return false;
    if (!(im_false == rhs.im_false))
      return false;
    if (!(a_bite == rhs.a_bite))
      return false;
    if (!(integer16 == rhs.integer16))
      return false;
    if (!(integer32 == rhs.integer32))
      return false;
    if (!(integer64 == rhs.integer64))
      return false;
    if (!(double_precision == rhs.double_precision))
      return false;
    if (!(some_characters == rhs.some_characters))
      return false;
    if (!(zomg_unicode == rhs.zomg_unicode))
      return false;
    if (!(what_who == rhs.what_who))
      return false;
    if (!(base64 == rhs.base64))
      return false;
    if (!(byte_list == rhs.byte_list))
      return false;
    if (!(i16_list == rhs.i16_list))
      return false;
    if (!(i64_list == rhs.i64_list))
      return false;
    return true;
  }
  bool operator != (const OneOfEach &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OneOfEach & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OneOfEach &a, OneOfEach &b);

std::ostream& operator<<(std::ostream& out, const OneOfEach& obj);

typedef struct _Bonk__isset {
  _Bonk__isset() : type(false), message(false) {}
  bool type :1;
  bool message :1;
} _Bonk__isset;

class Bonk : public virtual ::apache::thrift::TBase {
 public:

  Bonk(const Bonk&);
  Bonk& operator=(const Bonk&);
  Bonk() : type(0), message() {
  }

  virtual ~Bonk() throw();
  int32_t type;
  std::string message;

  _Bonk__isset __isset;

  void __set_type(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const Bonk & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Bonk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bonk & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Bonk &a, Bonk &b);

std::ostream& operator<<(std::ostream& out, const Bonk& obj);

typedef struct _Nesting__isset {
  _Nesting__isset() : my_bonk(false), my_ooe(false) {}
  bool my_bonk :1;
  bool my_ooe :1;
} _Nesting__isset;

class Nesting : public virtual ::apache::thrift::TBase {
 public:

  Nesting(const Nesting&);
  Nesting& operator=(const Nesting&);
  Nesting() {
  }

  virtual ~Nesting() throw();
  Bonk my_bonk;
  OneOfEach my_ooe;

  _Nesting__isset __isset;

  void __set_my_bonk(const Bonk& val);

  void __set_my_ooe(const OneOfEach& val);

  bool operator == (const Nesting & rhs) const
  {
    if (!(my_bonk == rhs.my_bonk))
      return false;
    if (!(my_ooe == rhs.my_ooe))
      return false;
    return true;
  }
  bool operator != (const Nesting &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Nesting & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Nesting &a, Nesting &b);

std::ostream& operator<<(std::ostream& out, const Nesting& obj);

typedef struct _HolyMoley__isset {
  _HolyMoley__isset() : big(false), contain(false), bonks(false) {}
  bool big :1;
  bool contain :1;
  bool bonks :1;
} _HolyMoley__isset;

class HolyMoley : public virtual ::apache::thrift::TBase {
 public:

  HolyMoley(const HolyMoley&);
  HolyMoley& operator=(const HolyMoley&);
  HolyMoley() {
  }

  virtual ~HolyMoley() throw();
  std::vector<OneOfEach>  big;
  std::set<std::vector<std::string> >  contain;
  std::map<std::string, std::vector<Bonk> >  bonks;

  _HolyMoley__isset __isset;

  void __set_big(const std::vector<OneOfEach> & val);

  void __set_contain(const std::set<std::vector<std::string> > & val);

  void __set_bonks(const std::map<std::string, std::vector<Bonk> > & val);

  bool operator == (const HolyMoley & rhs) const
  {
    if (!(big == rhs.big))
      return false;
    if (!(contain == rhs.contain))
      return false;
    if (!(bonks == rhs.bonks))
      return false;
    return true;
  }
  bool operator != (const HolyMoley &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HolyMoley & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HolyMoley &a, HolyMoley &b);

std::ostream& operator<<(std::ostream& out, const HolyMoley& obj);

typedef struct _Backwards__isset {
  _Backwards__isset() : first_tag2(false), second_tag1(false) {}
  bool first_tag2 :1;
  bool second_tag1 :1;
} _Backwards__isset;

class Backwards : public virtual ::apache::thrift::TBase {
 public:

  Backwards(const Backwards&);
  Backwards& operator=(const Backwards&);
  Backwards() : first_tag2(0), second_tag1(0) {
  }

  virtual ~Backwards() throw();
  int32_t first_tag2;
  int32_t second_tag1;

  _Backwards__isset __isset;

  void __set_first_tag2(const int32_t val);

  void __set_second_tag1(const int32_t val);

  bool operator == (const Backwards & rhs) const
  {
    if (!(first_tag2 == rhs.first_tag2))
      return false;
    if (!(second_tag1 == rhs.second_tag1))
      return false;
    return true;
  }
  bool operator != (const Backwards &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Backwards & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Backwards &a, Backwards &b);

std::ostream& operator<<(std::ostream& out, const Backwards& obj);


class Empty : public virtual ::apache::thrift::TBase {
 public:

  Empty(const Empty&);
  Empty& operator=(const Empty&);
  Empty() {
  }

  virtual ~Empty() throw();

  bool operator == (const Empty & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Empty &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Empty & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Empty &a, Empty &b);

std::ostream& operator<<(std::ostream& out, const Empty& obj);

typedef struct _Wrapper__isset {
  _Wrapper__isset() : foo(false) {}
  bool foo :1;
} _Wrapper__isset;

class Wrapper : public virtual ::apache::thrift::TBase {
 public:

  Wrapper(const Wrapper&);
  Wrapper& operator=(const Wrapper&);
  Wrapper() {
  }

  virtual ~Wrapper() throw();
  Empty foo;

  _Wrapper__isset __isset;

  void __set_foo(const Empty& val);

  bool operator == (const Wrapper & rhs) const
  {
    if (!(foo == rhs.foo))
      return false;
    return true;
  }
  bool operator != (const Wrapper &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Wrapper & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Wrapper &a, Wrapper &b);

std::ostream& operator<<(std::ostream& out, const Wrapper& obj);

typedef struct _RandomStuff__isset {
  _RandomStuff__isset() : a(false), b(false), c(false), d(false), myintlist(false), maps(false), bigint(false), triple(false) {}
  bool a :1;
  bool b :1;
  bool c :1;
  bool d :1;
  bool myintlist :1;
  bool maps :1;
  bool bigint :1;
  bool triple :1;
} _RandomStuff__isset;

class RandomStuff : public virtual ::apache::thrift::TBase {
 public:

  RandomStuff(const RandomStuff&);
  RandomStuff& operator=(const RandomStuff&);
  RandomStuff() : a(0), b(0), c(0), d(0), bigint(0), triple(0) {
  }

  virtual ~RandomStuff() throw();
  int32_t a;
  int32_t b;
  int32_t c;
  int32_t d;
  std::vector<int32_t>  myintlist;
  std::map<int32_t, Wrapper>  maps;
  int64_t bigint;
  double triple;

  _RandomStuff__isset __isset;

  void __set_a(const int32_t val);

  void __set_b(const int32_t val);

  void __set_c(const int32_t val);

  void __set_d(const int32_t val);

  void __set_myintlist(const std::vector<int32_t> & val);

  void __set_maps(const std::map<int32_t, Wrapper> & val);

  void __set_bigint(const int64_t val);

  void __set_triple(const double val);

  bool operator == (const RandomStuff & rhs) const
  {
    if (!(a == rhs.a))
      return false;
    if (!(b == rhs.b))
      return false;
    if (!(c == rhs.c))
      return false;
    if (!(d == rhs.d))
      return false;
    if (!(myintlist == rhs.myintlist))
      return false;
    if (!(maps == rhs.maps))
      return false;
    if (!(bigint == rhs.bigint))
      return false;
    if (!(triple == rhs.triple))
      return false;
    return true;
  }
  bool operator != (const RandomStuff &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RandomStuff & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RandomStuff &a, RandomStuff &b);

std::ostream& operator<<(std::ostream& out, const RandomStuff& obj);

typedef struct _Base64__isset {
  _Base64__isset() : a(false), b1(false), b2(false), b3(false), b4(false), b5(false), b6(false) {}
  bool a :1;
  bool b1 :1;
  bool b2 :1;
  bool b3 :1;
  bool b4 :1;
  bool b5 :1;
  bool b6 :1;
} _Base64__isset;

class Base64 : public virtual ::apache::thrift::TBase {
 public:

  Base64(const Base64&);
  Base64& operator=(const Base64&);
  Base64() : a(0), b1(), b2(), b3(), b4(), b5(), b6() {
  }

  virtual ~Base64() throw();
  int32_t a;
  std::string b1;
  std::string b2;
  std::string b3;
  std::string b4;
  std::string b5;
  std::string b6;

  _Base64__isset __isset;

  void __set_a(const int32_t val);

  void __set_b1(const std::string& val);

  void __set_b2(const std::string& val);

  void __set_b3(const std::string& val);

  void __set_b4(const std::string& val);

  void __set_b5(const std::string& val);

  void __set_b6(const std::string& val);

  bool operator == (const Base64 & rhs) const
  {
    if (!(a == rhs.a))
      return false;
    if (!(b1 == rhs.b1))
      return false;
    if (!(b2 == rhs.b2))
      return false;
    if (!(b3 == rhs.b3))
      return false;
    if (!(b4 == rhs.b4))
      return false;
    if (!(b5 == rhs.b5))
      return false;
    if (!(b6 == rhs.b6))
      return false;
    return true;
  }
  bool operator != (const Base64 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Base64 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Base64 &a, Base64 &b);

std::ostream& operator<<(std::ostream& out, const Base64& obj);

typedef struct _CompactProtoTestStruct__isset {
  _CompactProtoTestStruct__isset() : a_byte(false), a_i16(false), a_i32(false), a_i64(false), a_double(false), a_string(false), a_binary(false), true_field(false), false_field(false), empty_struct_field(false), byte_list(false), i16_list(false), i32_list(false), i64_list(false), double_list(false), string_list(false), binary_list(false), boolean_list(false), struct_list(false), byte_set(false), i16_set(false), i32_set(false), i64_set(false), double_set(false), string_set(false), binary_set(false), boolean_set(false), struct_set(false), byte_byte_map(false), i16_byte_map(false), i32_byte_map(false), i64_byte_map(false), double_byte_map(false), string_byte_map(false), binary_byte_map(false), boolean_byte_map(false), byte_i16_map(false), byte_i32_map(false), byte_i64_map(false), byte_double_map(false), byte_string_map(false), byte_binary_map(false), byte_boolean_map(false), list_byte_map(false), set_byte_map(false), map_byte_map(false), byte_map_map(false), byte_set_map(false), byte_list_map(false) {}
  bool a_byte :1;
  bool a_i16 :1;
  bool a_i32 :1;
  bool a_i64 :1;
  bool a_double :1;
  bool a_string :1;
  bool a_binary :1;
  bool true_field :1;
  bool false_field :1;
  bool empty_struct_field :1;
  bool byte_list :1;
  bool i16_list :1;
  bool i32_list :1;
  bool i64_list :1;
  bool double_list :1;
  bool string_list :1;
  bool binary_list :1;
  bool boolean_list :1;
  bool struct_list :1;
  bool byte_set :1;
  bool i16_set :1;
  bool i32_set :1;
  bool i64_set :1;
  bool double_set :1;
  bool string_set :1;
  bool binary_set :1;
  bool boolean_set :1;
  bool struct_set :1;
  bool byte_byte_map :1;
  bool i16_byte_map :1;
  bool i32_byte_map :1;
  bool i64_byte_map :1;
  bool double_byte_map :1;
  bool string_byte_map :1;
  bool binary_byte_map :1;
  bool boolean_byte_map :1;
  bool byte_i16_map :1;
  bool byte_i32_map :1;
  bool byte_i64_map :1;
  bool byte_double_map :1;
  bool byte_string_map :1;
  bool byte_binary_map :1;
  bool byte_boolean_map :1;
  bool list_byte_map :1;
  bool set_byte_map :1;
  bool map_byte_map :1;
  bool byte_map_map :1;
  bool byte_set_map :1;
  bool byte_list_map :1;
} _CompactProtoTestStruct__isset;

class CompactProtoTestStruct : public virtual ::apache::thrift::TBase {
 public:

  CompactProtoTestStruct(const CompactProtoTestStruct&);
  CompactProtoTestStruct& operator=(const CompactProtoTestStruct&);
  CompactProtoTestStruct() : a_byte(0), a_i16(0), a_i32(0), a_i64(0), a_double(0), a_string(), a_binary(), true_field(0), false_field(0) {
  }

  virtual ~CompactProtoTestStruct() throw();
  int8_t a_byte;
  int16_t a_i16;
  int32_t a_i32;
  int64_t a_i64;
  double a_double;
  std::string a_string;
  std::string a_binary;
  bool true_field;
  bool false_field;
  Empty empty_struct_field;
  std::vector<int8_t>  byte_list;
  std::vector<int16_t>  i16_list;
  std::vector<int32_t>  i32_list;
  std::vector<int64_t>  i64_list;
  std::vector<double>  double_list;
  std::vector<std::string>  string_list;
  std::vector<std::string>  binary_list;
  std::vector<bool>  boolean_list;
  std::vector<Empty>  struct_list;
  std::set<int8_t>  byte_set;
  std::set<int16_t>  i16_set;
  std::set<int32_t>  i32_set;
  std::set<int64_t>  i64_set;
  std::set<double>  double_set;
  std::set<std::string>  string_set;
  std::set<std::string>  binary_set;
  std::set<bool>  boolean_set;
  std::set<Empty>  struct_set;
  std::map<int8_t, int8_t>  byte_byte_map;
  std::map<int16_t, int8_t>  i16_byte_map;
  std::map<int32_t, int8_t>  i32_byte_map;
  std::map<int64_t, int8_t>  i64_byte_map;
  std::map<double, int8_t>  double_byte_map;
  std::map<std::string, int8_t>  string_byte_map;
  std::map<std::string, int8_t>  binary_byte_map;
  std::map<bool, int8_t>  boolean_byte_map;
  std::map<int8_t, int16_t>  byte_i16_map;
  std::map<int8_t, int32_t>  byte_i32_map;
  std::map<int8_t, int64_t>  byte_i64_map;
  std::map<int8_t, double>  byte_double_map;
  std::map<int8_t, std::string>  byte_string_map;
  std::map<int8_t, std::string>  byte_binary_map;
  std::map<int8_t, bool>  byte_boolean_map;
  std::map<std::vector<int8_t> , int8_t>  list_byte_map;
  std::map<std::set<int8_t> , int8_t>  set_byte_map;
  std::map<std::map<int8_t, int8_t> , int8_t>  map_byte_map;
  std::map<int8_t, std::map<int8_t, int8_t> >  byte_map_map;
  std::map<int8_t, std::set<int8_t> >  byte_set_map;
  std::map<int8_t, std::vector<int8_t> >  byte_list_map;

  _CompactProtoTestStruct__isset __isset;

  void __set_a_byte(const int8_t val);

  void __set_a_i16(const int16_t val);

  void __set_a_i32(const int32_t val);

  void __set_a_i64(const int64_t val);

  void __set_a_double(const double val);

  void __set_a_string(const std::string& val);

  void __set_a_binary(const std::string& val);

  void __set_true_field(const bool val);

  void __set_false_field(const bool val);

  void __set_empty_struct_field(const Empty& val);

  void __set_byte_list(const std::vector<int8_t> & val);

  void __set_i16_list(const std::vector<int16_t> & val);

  void __set_i32_list(const std::vector<int32_t> & val);

  void __set_i64_list(const std::vector<int64_t> & val);

  void __set_double_list(const std::vector<double> & val);

  void __set_string_list(const std::vector<std::string> & val);

  void __set_binary_list(const std::vector<std::string> & val);

  void __set_boolean_list(const std::vector<bool> & val);

  void __set_struct_list(const std::vector<Empty> & val);

  void __set_byte_set(const std::set<int8_t> & val);

  void __set_i16_set(const std::set<int16_t> & val);

  void __set_i32_set(const std::set<int32_t> & val);

  void __set_i64_set(const std::set<int64_t> & val);

  void __set_double_set(const std::set<double> & val);

  void __set_string_set(const std::set<std::string> & val);

  void __set_binary_set(const std::set<std::string> & val);

  void __set_boolean_set(const std::set<bool> & val);

  void __set_struct_set(const std::set<Empty> & val);

  void __set_byte_byte_map(const std::map<int8_t, int8_t> & val);

  void __set_i16_byte_map(const std::map<int16_t, int8_t> & val);

  void __set_i32_byte_map(const std::map<int32_t, int8_t> & val);

  void __set_i64_byte_map(const std::map<int64_t, int8_t> & val);

  void __set_double_byte_map(const std::map<double, int8_t> & val);

  void __set_string_byte_map(const std::map<std::string, int8_t> & val);

  void __set_binary_byte_map(const std::map<std::string, int8_t> & val);

  void __set_boolean_byte_map(const std::map<bool, int8_t> & val);

  void __set_byte_i16_map(const std::map<int8_t, int16_t> & val);

  void __set_byte_i32_map(const std::map<int8_t, int32_t> & val);

  void __set_byte_i64_map(const std::map<int8_t, int64_t> & val);

  void __set_byte_double_map(const std::map<int8_t, double> & val);

  void __set_byte_string_map(const std::map<int8_t, std::string> & val);

  void __set_byte_binary_map(const std::map<int8_t, std::string> & val);

  void __set_byte_boolean_map(const std::map<int8_t, bool> & val);

  void __set_list_byte_map(const std::map<std::vector<int8_t> , int8_t> & val);

  void __set_set_byte_map(const std::map<std::set<int8_t> , int8_t> & val);

  void __set_map_byte_map(const std::map<std::map<int8_t, int8_t> , int8_t> & val);

  void __set_byte_map_map(const std::map<int8_t, std::map<int8_t, int8_t> > & val);

  void __set_byte_set_map(const std::map<int8_t, std::set<int8_t> > & val);

  void __set_byte_list_map(const std::map<int8_t, std::vector<int8_t> > & val);

  bool operator == (const CompactProtoTestStruct & rhs) const
  {
    if (!(a_byte == rhs.a_byte))
      return false;
    if (!(a_i16 == rhs.a_i16))
      return false;
    if (!(a_i32 == rhs.a_i32))
      return false;
    if (!(a_i64 == rhs.a_i64))
      return false;
    if (!(a_double == rhs.a_double))
      return false;
    if (!(a_string == rhs.a_string))
      return false;
    if (!(a_binary == rhs.a_binary))
      return false;
    if (!(true_field == rhs.true_field))
      return false;
    if (!(false_field == rhs.false_field))
      return false;
    if (!(empty_struct_field == rhs.empty_struct_field))
      return false;
    if (!(byte_list == rhs.byte_list))
      return false;
    if (!(i16_list == rhs.i16_list))
      return false;
    if (!(i32_list == rhs.i32_list))
      return false;
    if (!(i64_list == rhs.i64_list))
      return false;
    if (!(double_list == rhs.double_list))
      return false;
    if (!(string_list == rhs.string_list))
      return false;
    if (!(binary_list == rhs.binary_list))
      return false;
    if (!(boolean_list == rhs.boolean_list))
      return false;
    if (!(struct_list == rhs.struct_list))
      return false;
    if (!(byte_set == rhs.byte_set))
      return false;
    if (!(i16_set == rhs.i16_set))
      return false;
    if (!(i32_set == rhs.i32_set))
      return false;
    if (!(i64_set == rhs.i64_set))
      return false;
    if (!(double_set == rhs.double_set))
      return false;
    if (!(string_set == rhs.string_set))
      return false;
    if (!(binary_set == rhs.binary_set))
      return false;
    if (!(boolean_set == rhs.boolean_set))
      return false;
    if (!(struct_set == rhs.struct_set))
      return false;
    if (!(byte_byte_map == rhs.byte_byte_map))
      return false;
    if (!(i16_byte_map == rhs.i16_byte_map))
      return false;
    if (!(i32_byte_map == rhs.i32_byte_map))
      return false;
    if (!(i64_byte_map == rhs.i64_byte_map))
      return false;
    if (!(double_byte_map == rhs.double_byte_map))
      return false;
    if (!(string_byte_map == rhs.string_byte_map))
      return false;
    if (!(binary_byte_map == rhs.binary_byte_map))
      return false;
    if (!(boolean_byte_map == rhs.boolean_byte_map))
      return false;
    if (!(byte_i16_map == rhs.byte_i16_map))
      return false;
    if (!(byte_i32_map == rhs.byte_i32_map))
      return false;
    if (!(byte_i64_map == rhs.byte_i64_map))
      return false;
    if (!(byte_double_map == rhs.byte_double_map))
      return false;
    if (!(byte_string_map == rhs.byte_string_map))
      return false;
    if (!(byte_binary_map == rhs.byte_binary_map))
      return false;
    if (!(byte_boolean_map == rhs.byte_boolean_map))
      return false;
    if (!(list_byte_map == rhs.list_byte_map))
      return false;
    if (!(set_byte_map == rhs.set_byte_map))
      return false;
    if (!(map_byte_map == rhs.map_byte_map))
      return false;
    if (!(byte_map_map == rhs.byte_map_map))
      return false;
    if (!(byte_set_map == rhs.byte_set_map))
      return false;
    if (!(byte_list_map == rhs.byte_list_map))
      return false;
    return true;
  }
  bool operator != (const CompactProtoTestStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactProtoTestStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactProtoTestStruct &a, CompactProtoTestStruct &b);

std::ostream& operator<<(std::ostream& out, const CompactProtoTestStruct& obj);


class SingleMapTestStruct : public virtual ::apache::thrift::TBase {
 public:

  SingleMapTestStruct(const SingleMapTestStruct&);
  SingleMapTestStruct& operator=(const SingleMapTestStruct&);
  SingleMapTestStruct() {
  }

  virtual ~SingleMapTestStruct() throw();
  std::map<int32_t, int32_t>  i32_map;

  void __set_i32_map(const std::map<int32_t, int32_t> & val);

  bool operator == (const SingleMapTestStruct & rhs) const
  {
    if (!(i32_map == rhs.i32_map))
      return false;
    return true;
  }
  bool operator != (const SingleMapTestStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SingleMapTestStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SingleMapTestStruct &a, SingleMapTestStruct &b);

std::ostream& operator<<(std::ostream& out, const SingleMapTestStruct& obj);

typedef struct _ExceptionWithAMap__isset {
  _ExceptionWithAMap__isset() : blah(false), map_field(false) {}
  bool blah :1;
  bool map_field :1;
} _ExceptionWithAMap__isset;

class ExceptionWithAMap : public ::apache::thrift::TException {
 public:

  ExceptionWithAMap(const ExceptionWithAMap&);
  ExceptionWithAMap& operator=(const ExceptionWithAMap&);
  ExceptionWithAMap() : blah() {
  }

  virtual ~ExceptionWithAMap() throw();
  std::string blah;
  std::map<std::string, std::string>  map_field;

  _ExceptionWithAMap__isset __isset;

  void __set_blah(const std::string& val);

  void __set_map_field(const std::map<std::string, std::string> & val);

  bool operator == (const ExceptionWithAMap & rhs) const
  {
    if (!(blah == rhs.blah))
      return false;
    if (!(map_field == rhs.map_field))
      return false;
    return true;
  }
  bool operator != (const ExceptionWithAMap &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExceptionWithAMap & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(ExceptionWithAMap &a, ExceptionWithAMap &b);

std::ostream& operator<<(std::ostream& out, const ExceptionWithAMap& obj);

typedef struct _BlowUp__isset {
  _BlowUp__isset() : b1(false), b2(false), b3(false), b4(false) {}
  bool b1 :1;
  bool b2 :1;
  bool b3 :1;
  bool b4 :1;
} _BlowUp__isset;

class BlowUp : public virtual ::apache::thrift::TBase {
 public:

  BlowUp(const BlowUp&);
  BlowUp& operator=(const BlowUp&);
  BlowUp() {
  }

  virtual ~BlowUp() throw();
  std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > >  b1;
  std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > >  b2;
  std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > >  b3;
  std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > >  b4;

  _BlowUp__isset __isset;

  void __set_b1(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val);

  void __set_b2(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val);

  void __set_b3(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val);

  void __set_b4(const std::map<std::vector<int32_t> , std::set<std::map<int32_t, std::string> > > & val);

  bool operator == (const BlowUp & rhs) const
  {
    if (!(b1 == rhs.b1))
      return false;
    if (!(b2 == rhs.b2))
      return false;
    if (!(b3 == rhs.b3))
      return false;
    if (!(b4 == rhs.b4))
      return false;
    return true;
  }
  bool operator != (const BlowUp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlowUp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BlowUp &a, BlowUp &b);

std::ostream& operator<<(std::ostream& out, const BlowUp& obj);

typedef struct _ReverseOrderStruct__isset {
  _ReverseOrderStruct__isset() : first(false), second(false), third(false), fourth(false) {}
  bool first :1;
  bool second :1;
  bool third :1;
  bool fourth :1;
} _ReverseOrderStruct__isset;

class ReverseOrderStruct : public virtual ::apache::thrift::TBase {
 public:

  ReverseOrderStruct(const ReverseOrderStruct&);
  ReverseOrderStruct& operator=(const ReverseOrderStruct&);
  ReverseOrderStruct() : first(), second(0), third(0), fourth(0) {
  }

  virtual ~ReverseOrderStruct() throw();
  std::string first;
  int16_t second;
  int32_t third;
  int64_t fourth;

  _ReverseOrderStruct__isset __isset;

  void __set_first(const std::string& val);

  void __set_second(const int16_t val);

  void __set_third(const int32_t val);

  void __set_fourth(const int64_t val);

  bool operator == (const ReverseOrderStruct & rhs) const
  {
    if (!(first == rhs.first))
      return false;
    if (!(second == rhs.second))
      return false;
    if (!(third == rhs.third))
      return false;
    if (!(fourth == rhs.fourth))
      return false;
    return true;
  }
  bool operator != (const ReverseOrderStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReverseOrderStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReverseOrderStruct &a, ReverseOrderStruct &b);

std::ostream& operator<<(std::ostream& out, const ReverseOrderStruct& obj);

typedef struct _StructWithSomeEnum__isset {
  _StructWithSomeEnum__isset() : blah(false) {}
  bool blah :1;
} _StructWithSomeEnum__isset;

class StructWithSomeEnum : public virtual ::apache::thrift::TBase {
 public:

  StructWithSomeEnum(const StructWithSomeEnum&);
  StructWithSomeEnum& operator=(const StructWithSomeEnum&);
  StructWithSomeEnum() : blah((SomeEnum::type)0) {
  }

  virtual ~StructWithSomeEnum() throw();
  SomeEnum::type blah;

  _StructWithSomeEnum__isset __isset;

  void __set_blah(const SomeEnum::type val);

  bool operator == (const StructWithSomeEnum & rhs) const
  {
    if (!(blah == rhs.blah))
      return false;
    return true;
  }
  bool operator != (const StructWithSomeEnum &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithSomeEnum & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StructWithSomeEnum &a, StructWithSomeEnum &b);

std::ostream& operator<<(std::ostream& out, const StructWithSomeEnum& obj);

typedef struct _TestUnion__isset {
  _TestUnion__isset() : string_field(false), i32_field(false), struct_field(false), struct_list(false), other_i32_field(false), enum_field(false), i32_set(false), i32_map(false) {}
  bool string_field :1;
  bool i32_field :1;
  bool struct_field :1;
  bool struct_list :1;
  bool other_i32_field :1;
  bool enum_field :1;
  bool i32_set :1;
  bool i32_map :1;
} _TestUnion__isset;

class TestUnion : public virtual ::apache::thrift::TBase {
 public:

  TestUnion(const TestUnion&);
  TestUnion& operator=(const TestUnion&);
  TestUnion() : string_field(), i32_field(0), other_i32_field(0), enum_field((SomeEnum::type)0) {
  }

  virtual ~TestUnion() throw();
  std::string string_field;
  int32_t i32_field;
  OneOfEach struct_field;
  std::vector<RandomStuff>  struct_list;
  int32_t other_i32_field;
  SomeEnum::type enum_field;
  std::set<int32_t>  i32_set;
  std::map<int32_t, int32_t>  i32_map;

  _TestUnion__isset __isset;

  void __set_string_field(const std::string& val);

  void __set_i32_field(const int32_t val);

  void __set_struct_field(const OneOfEach& val);

  void __set_struct_list(const std::vector<RandomStuff> & val);

  void __set_other_i32_field(const int32_t val);

  void __set_enum_field(const SomeEnum::type val);

  void __set_i32_set(const std::set<int32_t> & val);

  void __set_i32_map(const std::map<int32_t, int32_t> & val);

  bool operator == (const TestUnion & rhs) const
  {
    if (__isset.string_field != rhs.__isset.string_field)
      return false;
    else if (__isset.string_field && !(string_field == rhs.string_field))
      return false;
    if (__isset.i32_field != rhs.__isset.i32_field)
      return false;
    else if (__isset.i32_field && !(i32_field == rhs.i32_field))
      return false;
    if (__isset.struct_field != rhs.__isset.struct_field)
      return false;
    else if (__isset.struct_field && !(struct_field == rhs.struct_field))
      return false;
    if (__isset.struct_list != rhs.__isset.struct_list)
      return false;
    else if (__isset.struct_list && !(struct_list == rhs.struct_list))
      return false;
    if (__isset.other_i32_field != rhs.__isset.other_i32_field)
      return false;
    else if (__isset.other_i32_field && !(other_i32_field == rhs.other_i32_field))
      return false;
    if (__isset.enum_field != rhs.__isset.enum_field)
      return false;
    else if (__isset.enum_field && !(enum_field == rhs.enum_field))
      return false;
    if (__isset.i32_set != rhs.__isset.i32_set)
      return false;
    else if (__isset.i32_set && !(i32_set == rhs.i32_set))
      return false;
    if (__isset.i32_map != rhs.__isset.i32_map)
      return false;
    else if (__isset.i32_map && !(i32_map == rhs.i32_map))
      return false;
    return true;
  }
  bool operator != (const TestUnion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TestUnion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TestUnion &a, TestUnion &b);

std::ostream& operator<<(std::ostream& out, const TestUnion& obj);

typedef struct _TestUnionMinusStringField__isset {
  _TestUnionMinusStringField__isset() : i32_field(false), struct_field(false), struct_list(false), other_i32_field(false), enum_field(false), i32_set(false), i32_map(false) {}
  bool i32_field :1;
  bool struct_field :1;
  bool struct_list :1;
  bool other_i32_field :1;
  bool enum_field :1;
  bool i32_set :1;
  bool i32_map :1;
} _TestUnionMinusStringField__isset;

class TestUnionMinusStringField : public virtual ::apache::thrift::TBase {
 public:

  TestUnionMinusStringField(const TestUnionMinusStringField&);
  TestUnionMinusStringField& operator=(const TestUnionMinusStringField&);
  TestUnionMinusStringField() : i32_field(0), other_i32_field(0), enum_field((SomeEnum::type)0) {
  }

  virtual ~TestUnionMinusStringField() throw();
  int32_t i32_field;
  OneOfEach struct_field;
  std::vector<RandomStuff>  struct_list;
  int32_t other_i32_field;
  SomeEnum::type enum_field;
  std::set<int32_t>  i32_set;
  std::map<int32_t, int32_t>  i32_map;

  _TestUnionMinusStringField__isset __isset;

  void __set_i32_field(const int32_t val);

  void __set_struct_field(const OneOfEach& val);

  void __set_struct_list(const std::vector<RandomStuff> & val);

  void __set_other_i32_field(const int32_t val);

  void __set_enum_field(const SomeEnum::type val);

  void __set_i32_set(const std::set<int32_t> & val);

  void __set_i32_map(const std::map<int32_t, int32_t> & val);

  bool operator == (const TestUnionMinusStringField & rhs) const
  {
    if (__isset.i32_field != rhs.__isset.i32_field)
      return false;
    else if (__isset.i32_field && !(i32_field == rhs.i32_field))
      return false;
    if (__isset.struct_field != rhs.__isset.struct_field)
      return false;
    else if (__isset.struct_field && !(struct_field == rhs.struct_field))
      return false;
    if (__isset.struct_list != rhs.__isset.struct_list)
      return false;
    else if (__isset.struct_list && !(struct_list == rhs.struct_list))
      return false;
    if (__isset.other_i32_field != rhs.__isset.other_i32_field)
      return false;
    else if (__isset.other_i32_field && !(other_i32_field == rhs.other_i32_field))
      return false;
    if (__isset.enum_field != rhs.__isset.enum_field)
      return false;
    else if (__isset.enum_field && !(enum_field == rhs.enum_field))
      return false;
    if (__isset.i32_set != rhs.__isset.i32_set)
      return false;
    else if (__isset.i32_set && !(i32_set == rhs.i32_set))
      return false;
    if (__isset.i32_map != rhs.__isset.i32_map)
      return false;
    else if (__isset.i32_map && !(i32_map == rhs.i32_map))
      return false;
    return true;
  }
  bool operator != (const TestUnionMinusStringField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TestUnionMinusStringField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TestUnionMinusStringField &a, TestUnionMinusStringField &b);

std::ostream& operator<<(std::ostream& out, const TestUnionMinusStringField& obj);

typedef struct _ComparableUnion__isset {
  _ComparableUnion__isset() : string_field(false), binary_field(false) {}
  bool string_field :1;
  bool binary_field :1;
} _ComparableUnion__isset;

class ComparableUnion : public virtual ::apache::thrift::TBase {
 public:

  ComparableUnion(const ComparableUnion&);
  ComparableUnion& operator=(const ComparableUnion&);
  ComparableUnion() : string_field(), binary_field() {
  }

  virtual ~ComparableUnion() throw();
  std::string string_field;
  std::string binary_field;

  _ComparableUnion__isset __isset;

  void __set_string_field(const std::string& val);

  void __set_binary_field(const std::string& val);

  bool operator == (const ComparableUnion & rhs) const
  {
    if (__isset.string_field != rhs.__isset.string_field)
      return false;
    else if (__isset.string_field && !(string_field == rhs.string_field))
      return false;
    if (__isset.binary_field != rhs.__isset.binary_field)
      return false;
    else if (__isset.binary_field && !(binary_field == rhs.binary_field))
      return false;
    return true;
  }
  bool operator != (const ComparableUnion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ComparableUnion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ComparableUnion &a, ComparableUnion &b);

std::ostream& operator<<(std::ostream& out, const ComparableUnion& obj);

typedef struct _StructWithAUnion__isset {
  _StructWithAUnion__isset() : test_union(false) {}
  bool test_union :1;
} _StructWithAUnion__isset;

class StructWithAUnion : public virtual ::apache::thrift::TBase {
 public:

  StructWithAUnion(const StructWithAUnion&);
  StructWithAUnion& operator=(const StructWithAUnion&);
  StructWithAUnion() {
  }

  virtual ~StructWithAUnion() throw();
  TestUnion test_union;

  _StructWithAUnion__isset __isset;

  void __set_test_union(const TestUnion& val);

  bool operator == (const StructWithAUnion & rhs) const
  {
    if (!(test_union == rhs.test_union))
      return false;
    return true;
  }
  bool operator != (const StructWithAUnion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithAUnion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StructWithAUnion &a, StructWithAUnion &b);

std::ostream& operator<<(std::ostream& out, const StructWithAUnion& obj);

typedef struct _PrimitiveThenStruct__isset {
  _PrimitiveThenStruct__isset() : blah(false), blah2(false), bw(false) {}
  bool blah :1;
  bool blah2 :1;
  bool bw :1;
} _PrimitiveThenStruct__isset;

class PrimitiveThenStruct : public virtual ::apache::thrift::TBase {
 public:

  PrimitiveThenStruct(const PrimitiveThenStruct&);
  PrimitiveThenStruct& operator=(const PrimitiveThenStruct&);
  PrimitiveThenStruct() : blah(0), blah2(0) {
  }

  virtual ~PrimitiveThenStruct() throw();
  int32_t blah;
  int32_t blah2;
  Backwards bw;

  _PrimitiveThenStruct__isset __isset;

  void __set_blah(const int32_t val);

  void __set_blah2(const int32_t val);

  void __set_bw(const Backwards& val);

  bool operator == (const PrimitiveThenStruct & rhs) const
  {
    if (!(blah == rhs.blah))
      return false;
    if (!(blah2 == rhs.blah2))
      return false;
    if (!(bw == rhs.bw))
      return false;
    return true;
  }
  bool operator != (const PrimitiveThenStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrimitiveThenStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrimitiveThenStruct &a, PrimitiveThenStruct &b);

std::ostream& operator<<(std::ostream& out, const PrimitiveThenStruct& obj);


class StructWithASomemap : public virtual ::apache::thrift::TBase {
 public:

  StructWithASomemap(const StructWithASomemap&);
  StructWithASomemap& operator=(const StructWithASomemap&);
  StructWithASomemap() {
  }

  virtual ~StructWithASomemap() throw();
  SomeMap somemap_field;

  void __set_somemap_field(const SomeMap& val);

  bool operator == (const StructWithASomemap & rhs) const
  {
    if (!(somemap_field == rhs.somemap_field))
      return false;
    return true;
  }
  bool operator != (const StructWithASomemap &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithASomemap & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StructWithASomemap &a, StructWithASomemap &b);

std::ostream& operator<<(std::ostream& out, const StructWithASomemap& obj);

typedef struct _BigFieldIdStruct__isset {
  _BigFieldIdStruct__isset() : field1(false), field2(false) {}
  bool field1 :1;
  bool field2 :1;
} _BigFieldIdStruct__isset;

class BigFieldIdStruct : public virtual ::apache::thrift::TBase {
 public:

  BigFieldIdStruct(const BigFieldIdStruct&);
  BigFieldIdStruct& operator=(const BigFieldIdStruct&);
  BigFieldIdStruct() : field1(), field2() {
  }

  virtual ~BigFieldIdStruct() throw();
  std::string field1;
  std::string field2;

  _BigFieldIdStruct__isset __isset;

  void __set_field1(const std::string& val);

  void __set_field2(const std::string& val);

  bool operator == (const BigFieldIdStruct & rhs) const
  {
    if (!(field1 == rhs.field1))
      return false;
    if (!(field2 == rhs.field2))
      return false;
    return true;
  }
  bool operator != (const BigFieldIdStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BigFieldIdStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BigFieldIdStruct &a, BigFieldIdStruct &b);

std::ostream& operator<<(std::ostream& out, const BigFieldIdStruct& obj);

typedef struct _BreaksRubyCompactProtocol__isset {
  _BreaksRubyCompactProtocol__isset() : field1(false), field2(false), field3(false) {}
  bool field1 :1;
  bool field2 :1;
  bool field3 :1;
} _BreaksRubyCompactProtocol__isset;

class BreaksRubyCompactProtocol : public virtual ::apache::thrift::TBase {
 public:

  BreaksRubyCompactProtocol(const BreaksRubyCompactProtocol&);
  BreaksRubyCompactProtocol& operator=(const BreaksRubyCompactProtocol&);
  BreaksRubyCompactProtocol() : field1(), field3(0) {
  }

  virtual ~BreaksRubyCompactProtocol() throw();
  std::string field1;
  BigFieldIdStruct field2;
  int32_t field3;

  _BreaksRubyCompactProtocol__isset __isset;

  void __set_field1(const std::string& val);

  void __set_field2(const BigFieldIdStruct& val);

  void __set_field3(const int32_t val);

  bool operator == (const BreaksRubyCompactProtocol & rhs) const
  {
    if (!(field1 == rhs.field1))
      return false;
    if (!(field2 == rhs.field2))
      return false;
    if (!(field3 == rhs.field3))
      return false;
    return true;
  }
  bool operator != (const BreaksRubyCompactProtocol &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BreaksRubyCompactProtocol & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BreaksRubyCompactProtocol &a, BreaksRubyCompactProtocol &b);

std::ostream& operator<<(std::ostream& out, const BreaksRubyCompactProtocol& obj);

typedef struct _TupleProtocolTestStruct__isset {
  _TupleProtocolTestStruct__isset() : field1(false), field2(false), field3(false), field4(false), field5(false), field6(false), field7(false), field8(false), field9(false), field10(false), field11(false), field12(false) {}
  bool field1 :1;
  bool field2 :1;
  bool field3 :1;
  bool field4 :1;
  bool field5 :1;
  bool field6 :1;
  bool field7 :1;
  bool field8 :1;
  bool field9 :1;
  bool field10 :1;
  bool field11 :1;
  bool field12 :1;
} _TupleProtocolTestStruct__isset;

class TupleProtocolTestStruct : public virtual ::apache::thrift::TBase {
 public:

  TupleProtocolTestStruct(const TupleProtocolTestStruct&);
  TupleProtocolTestStruct& operator=(const TupleProtocolTestStruct&);
  TupleProtocolTestStruct() : field1(0), field2(0), field3(0), field4(0), field5(0), field6(0), field7(0), field8(0), field9(0), field10(0), field11(0), field12(0) {
  }

  virtual ~TupleProtocolTestStruct() throw();
  int32_t field1;
  int32_t field2;
  int32_t field3;
  int32_t field4;
  int32_t field5;
  int32_t field6;
  int32_t field7;
  int32_t field8;
  int32_t field9;
  int32_t field10;
  int32_t field11;
  int32_t field12;

  _TupleProtocolTestStruct__isset __isset;

  void __set_field1(const int32_t val);

  void __set_field2(const int32_t val);

  void __set_field3(const int32_t val);

  void __set_field4(const int32_t val);

  void __set_field5(const int32_t val);

  void __set_field6(const int32_t val);

  void __set_field7(const int32_t val);

  void __set_field8(const int32_t val);

  void __set_field9(const int32_t val);

  void __set_field10(const int32_t val);

  void __set_field11(const int32_t val);

  void __set_field12(const int32_t val);

  bool operator == (const TupleProtocolTestStruct & rhs) const
  {
    if (__isset.field1 != rhs.__isset.field1)
      return false;
    else if (__isset.field1 && !(field1 == rhs.field1))
      return false;
    if (__isset.field2 != rhs.__isset.field2)
      return false;
    else if (__isset.field2 && !(field2 == rhs.field2))
      return false;
    if (__isset.field3 != rhs.__isset.field3)
      return false;
    else if (__isset.field3 && !(field3 == rhs.field3))
      return false;
    if (__isset.field4 != rhs.__isset.field4)
      return false;
    else if (__isset.field4 && !(field4 == rhs.field4))
      return false;
    if (__isset.field5 != rhs.__isset.field5)
      return false;
    else if (__isset.field5 && !(field5 == rhs.field5))
      return false;
    if (__isset.field6 != rhs.__isset.field6)
      return false;
    else if (__isset.field6 && !(field6 == rhs.field6))
      return false;
    if (__isset.field7 != rhs.__isset.field7)
      return false;
    else if (__isset.field7 && !(field7 == rhs.field7))
      return false;
    if (__isset.field8 != rhs.__isset.field8)
      return false;
    else if (__isset.field8 && !(field8 == rhs.field8))
      return false;
    if (__isset.field9 != rhs.__isset.field9)
      return false;
    else if (__isset.field9 && !(field9 == rhs.field9))
      return false;
    if (__isset.field10 != rhs.__isset.field10)
      return false;
    else if (__isset.field10 && !(field10 == rhs.field10))
      return false;
    if (__isset.field11 != rhs.__isset.field11)
      return false;
    else if (__isset.field11 && !(field11 == rhs.field11))
      return false;
    if (__isset.field12 != rhs.__isset.field12)
      return false;
    else if (__isset.field12 && !(field12 == rhs.field12))
      return false;
    return true;
  }
  bool operator != (const TupleProtocolTestStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TupleProtocolTestStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TupleProtocolTestStruct &a, TupleProtocolTestStruct &b);

std::ostream& operator<<(std::ostream& out, const TupleProtocolTestStruct& obj);

typedef struct _ListDoublePerf__isset {
  _ListDoublePerf__isset() : field(false) {}
  bool field :1;
} _ListDoublePerf__isset;

class ListDoublePerf : public virtual ::apache::thrift::TBase {
 public:

  ListDoublePerf(const ListDoublePerf&);
  ListDoublePerf& operator=(const ListDoublePerf&);
  ListDoublePerf() {
  }

  virtual ~ListDoublePerf() throw();
  std::vector<double>  field;

  _ListDoublePerf__isset __isset;

  void __set_field(const std::vector<double> & val);

  bool operator == (const ListDoublePerf & rhs) const
  {
    if (!(field == rhs.field))
      return false;
    return true;
  }
  bool operator != (const ListDoublePerf &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListDoublePerf & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListDoublePerf &a, ListDoublePerf &b);

std::ostream& operator<<(std::ostream& out, const ListDoublePerf& obj);

}}} // namespace

#endif
