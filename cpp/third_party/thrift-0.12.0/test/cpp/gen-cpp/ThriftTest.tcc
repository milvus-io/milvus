/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ThriftTest.h"
#ifndef ThriftTest_TCC
#define ThriftTest_TCC

#include "thrift/async/TAsyncChannel.h"

namespace thrift { namespace test {


template <class Protocol_>
uint32_t ThriftTest_testVoid_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testVoid_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testVoid_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testVoid_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testVoid_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_presult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testString_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testString_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testString_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testString_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testString_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
  xfer += oprot->writeString((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBool_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBool_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBool_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBool_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testBool_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBool_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBool_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBool_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testByte_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testByte_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testByte_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
    xfer += oprot->writeByte(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testByte_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testByte_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
  xfer += oprot->writeByte((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI32_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI32_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testI32_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI32_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI32_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
  xfer += oprot->writeI32((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI64_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI64_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testI64_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testI64_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testI64_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
  xfer += oprot->writeI64((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testDouble_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testDouble_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
  xfer += oprot->writeDouble((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBinary_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBinary_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBinary_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBinary_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testBinary_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testBinary_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testBinary_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testBinary_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
  xfer += oprot->writeBinary((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thing.read(iprot);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thing)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testStruct_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStruct_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thing.read(iprot);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testNest_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testNest_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thing)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testNest_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testNest_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testNest_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->thing.clear();
            uint32_t _size290;
            ::apache::thrift::protocol::TType _ktype291;
            ::apache::thrift::protocol::TType _vtype292;
            xfer += iprot->readMapBegin(_ktype291, _vtype292, _size290);
            uint32_t _i294;
            for (_i294 = 0; _i294 < _size290; ++_i294)
            {
              int32_t _key295;
              xfer += iprot->readI32(_key295);
              int32_t& _val296 = this->thing[_key295];
              xfer += iprot->readI32(_val296);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMap_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter297;
    for (_iter297 = this->thing.begin(); _iter297 != this->thing.end(); ++_iter297)
    {
      xfer += oprot->writeI32(_iter297->first);
      xfer += oprot->writeI32(_iter297->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMap_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::map<int32_t, int32_t> ::const_iterator _iter298;
    for (_iter298 = (*(this->thing)).begin(); _iter298 != (*(this->thing)).end(); ++_iter298)
    {
      xfer += oprot->writeI32(_iter298->first);
      xfer += oprot->writeI32(_iter298->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size299;
            ::apache::thrift::protocol::TType _ktype300;
            ::apache::thrift::protocol::TType _vtype301;
            xfer += iprot->readMapBegin(_ktype300, _vtype301, _size299);
            uint32_t _i303;
            for (_i303 = 0; _i303 < _size299; ++_i303)
            {
              int32_t _key304;
              xfer += iprot->readI32(_key304);
              int32_t& _val305 = this->success[_key304];
              xfer += iprot->readI32(_val305);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter306;
      for (_iter306 = this->success.begin(); _iter306 != this->success.end(); ++_iter306)
      {
        xfer += oprot->writeI32(_iter306->first);
        xfer += oprot->writeI32(_iter306->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMap_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size307;
            ::apache::thrift::protocol::TType _ktype308;
            ::apache::thrift::protocol::TType _vtype309;
            xfer += iprot->readMapBegin(_ktype308, _vtype309, _size307);
            uint32_t _i311;
            for (_i311 = 0; _i311 < _size307; ++_i311)
            {
              int32_t _key312;
              xfer += iprot->readI32(_key312);
              int32_t& _val313 = (*(this->success))[_key312];
              xfer += iprot->readI32(_val313);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::map<int32_t, int32_t> ::const_iterator _iter314;
    for (_iter314 = (*(this->success)).begin(); _iter314 != (*(this->success)).end(); ++_iter314)
    {
      xfer += oprot->writeI32(_iter314->first);
      xfer += oprot->writeI32(_iter314->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->thing.clear();
            uint32_t _size315;
            ::apache::thrift::protocol::TType _ktype316;
            ::apache::thrift::protocol::TType _vtype317;
            xfer += iprot->readMapBegin(_ktype316, _vtype317, _size315);
            uint32_t _i319;
            for (_i319 = 0; _i319 < _size315; ++_i319)
            {
              std::string _key320;
              xfer += iprot->readString(_key320);
              std::string& _val321 = this->thing[_key320];
              xfer += iprot->readString(_val321);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->thing.size()));
    std::map<std::string, std::string> ::const_iterator _iter322;
    for (_iter322 = this->thing.begin(); _iter322 != this->thing.end(); ++_iter322)
    {
      xfer += oprot->writeString(_iter322->first);
      xfer += oprot->writeString(_iter322->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->thing)).size()));
    std::map<std::string, std::string> ::const_iterator _iter323;
    for (_iter323 = (*(this->thing)).begin(); _iter323 != (*(this->thing)).end(); ++_iter323)
    {
      xfer += oprot->writeString(_iter323->first);
      xfer += oprot->writeString(_iter323->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size324;
            ::apache::thrift::protocol::TType _ktype325;
            ::apache::thrift::protocol::TType _vtype326;
            xfer += iprot->readMapBegin(_ktype325, _vtype326, _size324);
            uint32_t _i328;
            for (_i328 = 0; _i328 < _size324; ++_i328)
            {
              std::string _key329;
              xfer += iprot->readString(_key329);
              std::string& _val330 = this->success[_key329];
              xfer += iprot->readString(_val330);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter331;
      for (_iter331 = this->success.begin(); _iter331 != this->success.end(); ++_iter331)
      {
        xfer += oprot->writeString(_iter331->first);
        xfer += oprot->writeString(_iter331->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testStringMap_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size332;
            ::apache::thrift::protocol::TType _ktype333;
            ::apache::thrift::protocol::TType _vtype334;
            xfer += iprot->readMapBegin(_ktype333, _vtype334, _size332);
            uint32_t _i336;
            for (_i336 = 0; _i336 < _size332; ++_i336)
            {
              std::string _key337;
              xfer += iprot->readString(_key337);
              std::string& _val338 = (*(this->success))[_key337];
              xfer += iprot->readString(_val338);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->success)).size()));
    std::map<std::string, std::string> ::const_iterator _iter339;
    for (_iter339 = (*(this->success)).begin(); _iter339 != (*(this->success)).end(); ++_iter339)
    {
      xfer += oprot->writeString(_iter339->first);
      xfer += oprot->writeString(_iter339->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->thing.clear();
            uint32_t _size340;
            ::apache::thrift::protocol::TType _etype343;
            xfer += iprot->readSetBegin(_etype343, _size340);
            uint32_t _i344;
            for (_i344 = 0; _i344 < _size340; ++_i344)
            {
              int32_t _elem345;
              xfer += iprot->readI32(_elem345);
              this->thing.insert(_elem345);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testSet_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::set<int32_t> ::const_iterator _iter346;
    for (_iter346 = this->thing.begin(); _iter346 != this->thing.end(); ++_iter346)
    {
      xfer += oprot->writeI32((*_iter346));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testSet_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::set<int32_t> ::const_iterator _iter347;
    for (_iter347 = (*(this->thing)).begin(); _iter347 != (*(this->thing)).end(); ++_iter347)
    {
      xfer += oprot->writeI32((*_iter347));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size348;
            ::apache::thrift::protocol::TType _etype351;
            xfer += iprot->readSetBegin(_etype351, _size348);
            uint32_t _i352;
            for (_i352 = 0; _i352 < _size348; ++_i352)
            {
              int32_t _elem353;
              xfer += iprot->readI32(_elem353);
              this->success.insert(_elem353);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testSet_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::set<int32_t> ::const_iterator _iter354;
      for (_iter354 = this->success.begin(); _iter354 != this->success.end(); ++_iter354)
      {
        xfer += oprot->writeI32((*_iter354));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testSet_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size355;
            ::apache::thrift::protocol::TType _etype358;
            xfer += iprot->readSetBegin(_etype358, _size355);
            uint32_t _i359;
            for (_i359 = 0; _i359 < _size355; ++_i359)
            {
              int32_t _elem360;
              xfer += iprot->readI32(_elem360);
              (*(this->success)).insert(_elem360);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testSet_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::set<int32_t> ::const_iterator _iter361;
    for (_iter361 = (*(this->success)).begin(); _iter361 != (*(this->success)).end(); ++_iter361)
    {
      xfer += oprot->writeI32((*_iter361));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thing.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _etype365;
            xfer += iprot->readListBegin(_etype365, _size362);
            this->thing.resize(_size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              xfer += iprot->readI32(this->thing[_i366]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testList_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::vector<int32_t> ::const_iterator _iter367;
    for (_iter367 = this->thing.begin(); _iter367 != this->thing.end(); ++_iter367)
    {
      xfer += oprot->writeI32((*_iter367));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testList_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::vector<int32_t> ::const_iterator _iter368;
    for (_iter368 = (*(this->thing)).begin(); _iter368 != (*(this->thing)).end(); ++_iter368)
    {
      xfer += oprot->writeI32((*_iter368));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size369;
            ::apache::thrift::protocol::TType _etype372;
            xfer += iprot->readListBegin(_etype372, _size369);
            this->success.resize(_size369);
            uint32_t _i373;
            for (_i373 = 0; _i373 < _size369; ++_i373)
            {
              xfer += iprot->readI32(this->success[_i373]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testList_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::vector<int32_t> ::const_iterator _iter374;
      for (_iter374 = this->success.begin(); _iter374 != this->success.end(); ++_iter374)
      {
        xfer += oprot->writeI32((*_iter374));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testList_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _etype378;
            xfer += iprot->readListBegin(_etype378, _size375);
            (*(this->success)).resize(_size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              xfer += iprot->readI32((*(this->success))[_i379]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testList_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<int32_t> ::const_iterator _iter380;
    for (_iter380 = (*(this->success)).begin(); _iter380 != (*(this->success)).end(); ++_iter380)
    {
      xfer += oprot->writeI32((*_iter380));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast381;
          xfer += iprot->readI32(ecast381);
          this->thing = (Numberz::type)ecast381;
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast382;
          xfer += iprot->readI32(ecast382);
          this->success = (Numberz::type)ecast382;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testEnum_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testEnum_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast383;
          xfer += iprot->readI32(ecast383);
          (*(this->success)) = (Numberz::type)ecast383;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
  xfer += oprot->writeI32((int32_t)(*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testTypedef_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
  xfer += oprot->writeI64((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hello);
          this->__isset.hello = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_args");

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->hello);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_pargs");

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->hello)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size384;
            ::apache::thrift::protocol::TType _ktype385;
            ::apache::thrift::protocol::TType _vtype386;
            xfer += iprot->readMapBegin(_ktype385, _vtype386, _size384);
            uint32_t _i388;
            for (_i388 = 0; _i388 < _size384; ++_i388)
            {
              int32_t _key389;
              xfer += iprot->readI32(_key389);
              std::map<int32_t, int32_t> & _val390 = this->success[_key389];
              {
                _val390.clear();
                uint32_t _size391;
                ::apache::thrift::protocol::TType _ktype392;
                ::apache::thrift::protocol::TType _vtype393;
                xfer += iprot->readMapBegin(_ktype392, _vtype393, _size391);
                uint32_t _i395;
                for (_i395 = 0; _i395 < _size391; ++_i395)
                {
                  int32_t _key396;
                  xfer += iprot->readI32(_key396);
                  int32_t& _val397 = _val390[_key396];
                  xfer += iprot->readI32(_val397);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, std::map<int32_t, int32_t> > ::const_iterator _iter398;
      for (_iter398 = this->success.begin(); _iter398 != this->success.end(); ++_iter398)
      {
        xfer += oprot->writeI32(_iter398->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter398->second.size()));
          std::map<int32_t, int32_t> ::const_iterator _iter399;
          for (_iter399 = _iter398->second.begin(); _iter399 != _iter398->second.end(); ++_iter399)
          {
            xfer += oprot->writeI32(_iter399->first);
            xfer += oprot->writeI32(_iter399->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMapMap_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size400;
            ::apache::thrift::protocol::TType _ktype401;
            ::apache::thrift::protocol::TType _vtype402;
            xfer += iprot->readMapBegin(_ktype401, _vtype402, _size400);
            uint32_t _i404;
            for (_i404 = 0; _i404 < _size400; ++_i404)
            {
              int32_t _key405;
              xfer += iprot->readI32(_key405);
              std::map<int32_t, int32_t> & _val406 = (*(this->success))[_key405];
              {
                _val406.clear();
                uint32_t _size407;
                ::apache::thrift::protocol::TType _ktype408;
                ::apache::thrift::protocol::TType _vtype409;
                xfer += iprot->readMapBegin(_ktype408, _vtype409, _size407);
                uint32_t _i411;
                for (_i411 = 0; _i411 < _size407; ++_i411)
                {
                  int32_t _key412;
                  xfer += iprot->readI32(_key412);
                  int32_t& _val413 = _val406[_key412];
                  xfer += iprot->readI32(_val413);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->success)).size()));
    std::map<int32_t, std::map<int32_t, int32_t> > ::const_iterator _iter414;
    for (_iter414 = (*(this->success)).begin(); _iter414 != (*(this->success)).end(); ++_iter414)
    {
      xfer += oprot->writeI32(_iter414->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter414->second.size()));
        std::map<int32_t, int32_t> ::const_iterator _iter415;
        for (_iter415 = _iter414->second.begin(); _iter415 != _iter414->second.end(); ++_iter415)
        {
          xfer += oprot->writeI32(_iter415->first);
          xfer += oprot->writeI32(_iter415->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->argument.read(iprot);
          this->__isset.argument = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_args");

  xfer += oprot->writeFieldBegin("argument", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->argument.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_pargs");

  xfer += oprot->writeFieldBegin("argument", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->argument)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size416;
            ::apache::thrift::protocol::TType _ktype417;
            ::apache::thrift::protocol::TType _vtype418;
            xfer += iprot->readMapBegin(_ktype417, _vtype418, _size416);
            uint32_t _i420;
            for (_i420 = 0; _i420 < _size416; ++_i420)
            {
              UserId _key421;
              xfer += iprot->readI64(_key421);
              std::map<Numberz::type, Insanity> & _val422 = this->success[_key421];
              {
                _val422.clear();
                uint32_t _size423;
                ::apache::thrift::protocol::TType _ktype424;
                ::apache::thrift::protocol::TType _vtype425;
                xfer += iprot->readMapBegin(_ktype424, _vtype425, _size423);
                uint32_t _i427;
                for (_i427 = 0; _i427 < _size423; ++_i427)
                {
                  Numberz::type _key428;
                  int32_t ecast430;
                  xfer += iprot->readI32(ecast430);
                  _key428 = (Numberz::type)ecast430;
                  Insanity& _val429 = _val422[_key428];
                  xfer += _val429.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<UserId, std::map<Numberz::type, Insanity> > ::const_iterator _iter431;
      for (_iter431 = this->success.begin(); _iter431 != this->success.end(); ++_iter431)
      {
        xfer += oprot->writeI64(_iter431->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter431->second.size()));
          std::map<Numberz::type, Insanity> ::const_iterator _iter432;
          for (_iter432 = _iter431->second.begin(); _iter432 != _iter431->second.end(); ++_iter432)
          {
            xfer += oprot->writeI32((int32_t)_iter432->first);
            xfer += _iter432->second.write(oprot);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testInsanity_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size433;
            ::apache::thrift::protocol::TType _ktype434;
            ::apache::thrift::protocol::TType _vtype435;
            xfer += iprot->readMapBegin(_ktype434, _vtype435, _size433);
            uint32_t _i437;
            for (_i437 = 0; _i437 < _size433; ++_i437)
            {
              UserId _key438;
              xfer += iprot->readI64(_key438);
              std::map<Numberz::type, Insanity> & _val439 = (*(this->success))[_key438];
              {
                _val439.clear();
                uint32_t _size440;
                ::apache::thrift::protocol::TType _ktype441;
                ::apache::thrift::protocol::TType _vtype442;
                xfer += iprot->readMapBegin(_ktype441, _vtype442, _size440);
                uint32_t _i444;
                for (_i444 = 0; _i444 < _size440; ++_i444)
                {
                  Numberz::type _key445;
                  int32_t ecast447;
                  xfer += iprot->readI32(ecast447);
                  _key445 = (Numberz::type)ecast447;
                  Insanity& _val446 = _val439[_key445];
                  xfer += _val446.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->success)).size()));
    std::map<UserId, std::map<Numberz::type, Insanity> > ::const_iterator _iter448;
    for (_iter448 = (*(this->success)).begin(); _iter448 != (*(this->success)).end(); ++_iter448)
    {
      xfer += oprot->writeI64(_iter448->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter448->second.size()));
        std::map<Numberz::type, Insanity> ::const_iterator _iter449;
        for (_iter449 = _iter448->second.begin(); _iter449 != _iter448->second.end(); ++_iter449)
        {
          xfer += oprot->writeI32((int32_t)_iter449->first);
          xfer += _iter449->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->arg0);
          this->__isset.arg0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->arg1);
          this->__isset.arg1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg2);
          this->__isset.arg2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->arg3.clear();
            uint32_t _size450;
            ::apache::thrift::protocol::TType _ktype451;
            ::apache::thrift::protocol::TType _vtype452;
            xfer += iprot->readMapBegin(_ktype451, _vtype452, _size450);
            uint32_t _i454;
            for (_i454 = 0; _i454 < _size450; ++_i454)
            {
              int16_t _key455;
              xfer += iprot->readI16(_key455);
              std::string& _val456 = this->arg3[_key455];
              xfer += iprot->readString(_val456);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.arg3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast457;
          xfer += iprot->readI32(ecast457);
          this->arg4 = (Numberz::type)ecast457;
          this->__isset.arg4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg5);
          this->__isset.arg5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_args");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->arg0);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->arg1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->arg2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg3", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arg3.size()));
    std::map<int16_t, std::string> ::const_iterator _iter458;
    for (_iter458 = this->arg3.begin(); _iter458 != this->arg3.end(); ++_iter458)
    {
      xfer += oprot->writeI16(_iter458->first);
      xfer += oprot->writeString(_iter458->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg4", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->arg4);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg5", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->arg5);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_pargs");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte((*(this->arg0)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->arg1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->arg2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg3", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->arg3)).size()));
    std::map<int16_t, std::string> ::const_iterator _iter459;
    for (_iter459 = (*(this->arg3)).begin(); _iter459 != (*(this->arg3)).end(); ++_iter459)
    {
      xfer += oprot->writeI16(_iter459->first);
      xfer += oprot->writeString(_iter459->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg4", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)(*(this->arg4)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg5", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64((*(this->arg5)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMulti_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMulti_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg);
          this->__isset.arg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testException_args");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->arg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testException_pargs");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->arg)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testException_result");

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testException_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testException_presult");

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg0);
          this->__isset.arg0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg1);
          this->__isset.arg1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_args");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->arg0);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->arg1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_pargs");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->arg0)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->arg1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_result::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err2.read(iprot);
          this->__isset.err2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.err2) {
    xfer += oprot->writeFieldBegin("err2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testMultiException_presult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err2.read(iprot);
          this->__isset.err2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.err2) {
    xfer += oprot->writeFieldBegin("err2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testOneway_args::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secondsToSleep);
          this->__isset.secondsToSleep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testOneway_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testOneway_args");

  xfer += oprot->writeFieldBegin("secondsToSleep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->secondsToSleep);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


template <class Protocol_>
uint32_t ThriftTest_testOneway_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTest_testOneway_pargs");

  xfer += oprot->writeFieldBegin("secondsToSleep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->secondsToSleep)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testVoid()
{
  send_testVoid();
  recv_testVoid();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testVoid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testVoid") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testVoid_presult result;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  return;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testString(std::string& _return, const std::string& thing)
{
  send_testString(thing);
  recv_testString(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testString(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testString") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testString_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
}

template <class Protocol_>
bool ThriftTestClientT<Protocol_>::testBool(const bool thing)
{
  send_testBool(thing);
  return recv_testBool();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testBool(const bool thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testBool", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBool_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
bool ThriftTestClientT<Protocol_>::recv_testBool()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testBool") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  bool _return;
  ThriftTest_testBool_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBool failed: unknown result");
}

template <class Protocol_>
int8_t ThriftTestClientT<Protocol_>::testByte(const int8_t thing)
{
  send_testByte(thing);
  return recv_testByte();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int8_t ThriftTestClientT<Protocol_>::recv_testByte()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testByte") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int8_t _return;
  ThriftTest_testByte_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
}

template <class Protocol_>
int32_t ThriftTestClientT<Protocol_>::testI32(const int32_t thing)
{
  send_testI32(thing);
  return recv_testI32();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int32_t ThriftTestClientT<Protocol_>::recv_testI32()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testI32") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  ThriftTest_testI32_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
}

template <class Protocol_>
int64_t ThriftTestClientT<Protocol_>::testI64(const int64_t thing)
{
  send_testI64(thing);
  return recv_testI64();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int64_t ThriftTestClientT<Protocol_>::recv_testI64()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testI64") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  ThriftTest_testI64_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
}

template <class Protocol_>
double ThriftTestClientT<Protocol_>::testDouble(const double thing)
{
  send_testDouble(thing);
  return recv_testDouble();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
double ThriftTestClientT<Protocol_>::recv_testDouble()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testDouble") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  double _return;
  ThriftTest_testDouble_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testBinary(std::string& _return, const std::string& thing)
{
  send_testBinary(thing);
  recv_testBinary(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testBinary(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBinary_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testBinary(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testBinary") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testBinary_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBinary failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testStruct(Xtruct& _return, const Xtruct& thing)
{
  send_testStruct(thing);
  recv_testStruct(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testStruct(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testStruct") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testStruct_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testNest(Xtruct2& _return, const Xtruct2& thing)
{
  send_testNest(thing);
  recv_testNest(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testNest(Xtruct2& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testNest") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testNest_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing)
{
  send_testMap(thing);
  recv_testMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing)
{
  send_testStringMap(thing);
  recv_testStringMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testStringMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testStringMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing)
{
  send_testSet(thing);
  recv_testSet(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testSet") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testSet_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing)
{
  send_testList(thing);
  recv_testList(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testList") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testList_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
}

template <class Protocol_>
Numberz::type ThriftTestClientT<Protocol_>::testEnum(const Numberz::type thing)
{
  send_testEnum(thing);
  return recv_testEnum();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
Numberz::type ThriftTestClientT<Protocol_>::recv_testEnum()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testEnum") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  Numberz::type _return;
  ThriftTest_testEnum_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
}

template <class Protocol_>
UserId ThriftTestClientT<Protocol_>::testTypedef(const UserId thing)
{
  send_testTypedef(thing);
  return recv_testTypedef();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
UserId ThriftTestClientT<Protocol_>::recv_testTypedef()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testTypedef") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  UserId _return;
  ThriftTest_testTypedef_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello)
{
  send_testMapMap(hello);
  recv_testMapMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMapMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMapMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument)
{
  send_testInsanity(argument);
  recv_testInsanity(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testInsanity") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testInsanity_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  recv_testMulti(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMulti(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMulti") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMulti_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testException(const std::string& arg)
{
  send_testException(arg);
  recv_testException();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testException()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testException") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testException_presult result;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.err1) {
    throw result.err1;
  }
  return;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1)
{
  send_testMultiException(arg0, arg1);
  recv_testMultiException(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMultiException(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMultiException") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMultiException_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.err1) {
    throw result.err1;
  }
  if (result.__isset.err2) {
    throw result.err2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testOneway(const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
bool ThriftTestProcessorT<Protocol_>::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second.generic))(seqid, iprot, oprot, callContext);
  return true;
}

template <class Protocol_>
bool ThriftTestProcessorT<Protocol_>::dispatchCallTemplated(Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second.specialized))(seqid, iprot, oprot, callContext);
  return true;
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testVoid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
  }

  ThriftTest_testVoid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
  }

  ThriftTest_testVoid_result result;
  try {
    iface_->testVoid();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testVoid(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
  }

  ThriftTest_testVoid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
  }

  ThriftTest_testVoid_result result;
  try {
    iface_->testVoid();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testString");
  }

  ThriftTest_testString_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
  }

  ThriftTest_testString_result result;
  try {
    iface_->testString(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testString(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testString");
  }

  ThriftTest_testString_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
  }

  ThriftTest_testString_result result;
  try {
    iface_->testString(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
  }

  ThriftTest_testBool_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
  }

  ThriftTest_testBool_result result;
  try {
    result.success = iface_->testBool(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBool(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
  }

  ThriftTest_testBool_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
  }

  ThriftTest_testBool_result result;
  try {
    result.success = iface_->testBool(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testByte(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
  }

  ThriftTest_testByte_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
  }

  ThriftTest_testByte_result result;
  try {
    result.success = iface_->testByte(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testByte(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
  }

  ThriftTest_testByte_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
  }

  ThriftTest_testByte_result result;
  try {
    result.success = iface_->testByte(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI32(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
  }

  ThriftTest_testI32_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
  }

  ThriftTest_testI32_result result;
  try {
    result.success = iface_->testI32(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI32(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
  }

  ThriftTest_testI32_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
  }

  ThriftTest_testI32_result result;
  try {
    result.success = iface_->testI32(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI64(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
  }

  ThriftTest_testI64_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
  }

  ThriftTest_testI64_result result;
  try {
    result.success = iface_->testI64(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI64(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
  }

  ThriftTest_testI64_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
  }

  ThriftTest_testI64_result result;
  try {
    result.success = iface_->testI64(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testDouble(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
  }

  ThriftTest_testDouble_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
  }

  ThriftTest_testDouble_result result;
  try {
    result.success = iface_->testDouble(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testDouble(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
  }

  ThriftTest_testDouble_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
  }

  ThriftTest_testDouble_result result;
  try {
    result.success = iface_->testDouble(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBinary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
  }

  ThriftTest_testBinary_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
  }

  ThriftTest_testBinary_result result;
  try {
    iface_->testBinary(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testBinary(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
  }

  ThriftTest_testBinary_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
  }

  ThriftTest_testBinary_result result;
  try {
    iface_->testBinary(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStruct(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
  }

  ThriftTest_testStruct_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
  }

  ThriftTest_testStruct_result result;
  try {
    iface_->testStruct(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStruct(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
  }

  ThriftTest_testStruct_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
  }

  ThriftTest_testStruct_result result;
  try {
    iface_->testStruct(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testNest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
  }

  ThriftTest_testNest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
  }

  ThriftTest_testNest_result result;
  try {
    iface_->testNest(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testNest(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
  }

  ThriftTest_testNest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
  }

  ThriftTest_testNest_result result;
  try {
    iface_->testNest(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
  }

  ThriftTest_testMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
  }

  ThriftTest_testMap_result result;
  try {
    iface_->testMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
  }

  ThriftTest_testMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
  }

  ThriftTest_testMap_result result;
  try {
    iface_->testMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStringMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
  }

  ThriftTest_testStringMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
  }

  ThriftTest_testStringMap_result result;
  try {
    iface_->testStringMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStringMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
  }

  ThriftTest_testStringMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
  }

  ThriftTest_testStringMap_result result;
  try {
    iface_->testStringMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
  }

  ThriftTest_testSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
  }

  ThriftTest_testSet_result result;
  try {
    iface_->testSet(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testSet(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
  }

  ThriftTest_testSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
  }

  ThriftTest_testSet_result result;
  try {
    iface_->testSet(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testList");
  }

  ThriftTest_testList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
  }

  ThriftTest_testList_result result;
  try {
    iface_->testList(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testList(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testList");
  }

  ThriftTest_testList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
  }

  ThriftTest_testList_result result;
  try {
    iface_->testList(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testEnum(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
  }

  ThriftTest_testEnum_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
  }

  ThriftTest_testEnum_result result;
  try {
    result.success = iface_->testEnum(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testEnum(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
  }

  ThriftTest_testEnum_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
  }

  ThriftTest_testEnum_result result;
  try {
    result.success = iface_->testEnum(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testTypedef(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
  }

  ThriftTest_testTypedef_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
  }

  ThriftTest_testTypedef_result result;
  try {
    result.success = iface_->testTypedef(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testTypedef(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
  }

  ThriftTest_testTypedef_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
  }

  ThriftTest_testTypedef_result result;
  try {
    result.success = iface_->testTypedef(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMapMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
  }

  ThriftTest_testMapMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
  }

  ThriftTest_testMapMap_result result;
  try {
    iface_->testMapMap(result.success, args.hello);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMapMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
  }

  ThriftTest_testMapMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
  }

  ThriftTest_testMapMap_result result;
  try {
    iface_->testMapMap(result.success, args.hello);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testInsanity(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
  }

  ThriftTest_testInsanity_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
  }

  ThriftTest_testInsanity_result result;
  try {
    iface_->testInsanity(result.success, args.argument);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testInsanity(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
  }

  ThriftTest_testInsanity_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
  }

  ThriftTest_testInsanity_result result;
  try {
    iface_->testInsanity(result.success, args.argument);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMulti(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
  }

  ThriftTest_testMulti_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
  }

  ThriftTest_testMulti_result result;
  try {
    iface_->testMulti(result.success, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMulti(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
  }

  ThriftTest_testMulti_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
  }

  ThriftTest_testMulti_result result;
  try {
    iface_->testMulti(result.success, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testException");
  }

  ThriftTest_testException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
  }

  ThriftTest_testException_result result;
  try {
    iface_->testException(args.arg);
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testException(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testException");
  }

  ThriftTest_testException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
  }

  ThriftTest_testException_result result;
  try {
    iface_->testException(args.arg);
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMultiException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
  }

  ThriftTest_testMultiException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
  }

  ThriftTest_testMultiException_result result;
  try {
    iface_->testMultiException(result.success, args.arg0, args.arg1);
    result.__isset.success = true;
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMultiException(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
  }

  ThriftTest_testMultiException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
  }

  ThriftTest_testMultiException_result result;
  try {
    iface_->testMultiException(result.success, args.arg0, args.arg1);
    result.__isset.success = true;
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testOneway(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  (void) seqid;
  (void) oprot;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
  }

  ThriftTest_testOneway_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
  }

  try {
    iface_->testOneway(args.secondsToSleep);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }

  return;
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testOneway(int32_t, Protocol_* iprot, Protocol_*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
  }

  ThriftTest_testOneway_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
  }

  try {
    iface_->testOneway(args.secondsToSleep);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }

  return;
}

template <class Protocol_>
::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > ThriftTestProcessorFactoryT<Protocol_>::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ThriftTestIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< ThriftTestIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new ThriftTestProcessorT<Protocol_>(handler));
  return processor;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testVoid()
{
  int32_t seqid = send_testVoid();
  recv_testVoid(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testVoid(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testVoid") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testVoid_presult result;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testString(std::string& _return, const std::string& thing)
{
  int32_t seqid = send_testString(thing);
  recv_testString(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testString(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testString") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testString_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
bool ThriftTestConcurrentClientT<Protocol_>::testBool(const bool thing)
{
  int32_t seqid = send_testBool(thing);
  return recv_testBool(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testBool(const bool thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testBool", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBool_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
bool ThriftTestConcurrentClientT<Protocol_>::recv_testBool(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testBool") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ThriftTest_testBool_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBool failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
int8_t ThriftTestConcurrentClientT<Protocol_>::testByte(const int8_t thing)
{
  int32_t seqid = send_testByte(thing);
  return recv_testByte(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
int8_t ThriftTestConcurrentClientT<Protocol_>::recv_testByte(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testByte") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int8_t _return;
      ThriftTest_testByte_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::testI32(const int32_t thing)
{
  int32_t seqid = send_testI32(thing);
  return recv_testI32(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::recv_testI32(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testI32") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      ThriftTest_testI32_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
int64_t ThriftTestConcurrentClientT<Protocol_>::testI64(const int64_t thing)
{
  int32_t seqid = send_testI64(thing);
  return recv_testI64(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
int64_t ThriftTestConcurrentClientT<Protocol_>::recv_testI64(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testI64") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      ThriftTest_testI64_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
double ThriftTestConcurrentClientT<Protocol_>::testDouble(const double thing)
{
  int32_t seqid = send_testDouble(thing);
  return recv_testDouble(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
double ThriftTestConcurrentClientT<Protocol_>::recv_testDouble(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testDouble") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      ThriftTest_testDouble_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testBinary(std::string& _return, const std::string& thing)
{
  int32_t seqid = send_testBinary(thing);
  recv_testBinary(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testBinary(const std::string& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBinary_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testBinary(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testBinary") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testBinary_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBinary failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testStruct(Xtruct& _return, const Xtruct& thing)
{
  int32_t seqid = send_testStruct(thing);
  recv_testStruct(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testStruct(Xtruct& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testStruct") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testStruct_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testNest(Xtruct2& _return, const Xtruct2& thing)
{
  int32_t seqid = send_testNest(thing);
  recv_testNest(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testNest(Xtruct2& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testNest") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testNest_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing)
{
  int32_t seqid = send_testMap(thing);
  recv_testMap(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMap") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMap_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing)
{
  int32_t seqid = send_testStringMap(thing);
  recv_testStringMap(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testStringMap") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testStringMap_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing)
{
  int32_t seqid = send_testSet(thing);
  recv_testSet(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testSet") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testSet_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing)
{
  int32_t seqid = send_testList(thing);
  recv_testList(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testList") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testList_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
Numberz::type ThriftTestConcurrentClientT<Protocol_>::testEnum(const Numberz::type thing)
{
  int32_t seqid = send_testEnum(thing);
  return recv_testEnum(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
Numberz::type ThriftTestConcurrentClientT<Protocol_>::recv_testEnum(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testEnum") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Numberz::type _return;
      ThriftTest_testEnum_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
UserId ThriftTestConcurrentClientT<Protocol_>::testTypedef(const UserId thing)
{
  int32_t seqid = send_testTypedef(thing);
  return recv_testTypedef(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
UserId ThriftTestConcurrentClientT<Protocol_>::recv_testTypedef(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testTypedef") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      UserId _return;
      ThriftTest_testTypedef_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello)
{
  int32_t seqid = send_testMapMap(hello);
  recv_testMapMap(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMapMap") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMapMap_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument)
{
  int32_t seqid = send_testInsanity(argument);
  recv_testInsanity(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testInsanity") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testInsanity_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t seqid = send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  recv_testMulti(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMulti(Xtruct& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMulti") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMulti_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testException(const std::string& arg)
{
  int32_t seqid = send_testException(arg);
  recv_testException(seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testException(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testException") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testException_presult result;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.err1) {
        sentry.commit();
        throw result.err1;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1)
{
  int32_t seqid = send_testMultiException(arg0, arg1);
  recv_testMultiException(_return, seqid);
}

template <class Protocol_>
int32_t ThriftTestConcurrentClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::recv_testMultiException(Xtruct& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      this->iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(this->iprot_);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();
      }
      if (fname.compare("testMultiException") != 0) {
        this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        this->iprot_->readMessageEnd();
        this->iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ThriftTest_testMultiException_presult result;
      result.success = &_return;
      result.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.err1) {
        sentry.commit();
        throw result.err1;
      }
      if (result.__isset.err2) {
        sentry.commit();
        throw result.err2;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::testOneway(const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
}

template <class Protocol_>
void ThriftTestConcurrentClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();

  sentry.commit();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testVoid(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob)
{
  send_testVoid();
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testVoid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testVoid") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testVoid_presult result;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    completed = true;
    completed__(true);
    return;
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testString(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& thing)
{
  send_testString(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testString(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testString") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testString_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testBool(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const bool thing)
{
  send_testBool(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testBool(const bool thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testBool", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBool_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
bool ThriftTestCobClientT<Protocol_>::recv_testBool()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testBool") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    ThriftTest_testBool_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBool failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testByte(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int8_t thing)
{
  send_testByte(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int8_t ThriftTestCobClientT<Protocol_>::recv_testByte()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testByte") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int8_t _return;
    ThriftTest_testByte_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testI32(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t thing)
{
  send_testI32(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int32_t ThriftTestCobClientT<Protocol_>::recv_testI32()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testI32") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int32_t _return;
    ThriftTest_testI32_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testI64(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int64_t thing)
{
  send_testI64(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int64_t ThriftTestCobClientT<Protocol_>::recv_testI64()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testI64") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int64_t _return;
    ThriftTest_testI64_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testDouble(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const double thing)
{
  send_testDouble(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
double ThriftTestCobClientT<Protocol_>::recv_testDouble()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testDouble") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    double _return;
    ThriftTest_testDouble_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testBinary(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& thing)
{
  send_testBinary(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testBinary(const std::string& thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testBinary_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testBinary(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testBinary") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testBinary_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testBinary failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testStruct(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Xtruct& thing)
{
  send_testStruct(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testStruct(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testStruct") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testStruct_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testNest(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Xtruct2& thing)
{
  send_testNest(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testNest(Xtruct2& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testNest") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testNest_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMap(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::map<int32_t, int32_t> & thing)
{
  send_testMap(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testStringMap(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::map<std::string, std::string> & thing)
{
  send_testStringMap(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testStringMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testStringMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testSet(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::set<int32_t> & thing)
{
  send_testSet(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testSet") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testSet_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testList(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::vector<int32_t> & thing)
{
  send_testList(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testList") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testList_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testEnum(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Numberz::type thing)
{
  send_testEnum(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
Numberz::type ThriftTestCobClientT<Protocol_>::recv_testEnum()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testEnum") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    Numberz::type _return;
    ThriftTest_testEnum_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testTypedef(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const UserId thing)
{
  send_testTypedef(thing);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
UserId ThriftTestCobClientT<Protocol_>::recv_testTypedef()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testTypedef") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    UserId _return;
    ThriftTest_testTypedef_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMapMap(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t hello)
{
  send_testMapMap(hello);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMapMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMapMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testInsanity(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Insanity& argument)
{
  send_testInsanity(argument);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testInsanity") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testInsanity_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMulti(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMulti(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMulti") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMulti_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testException(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& arg)
{
  send_testException(arg);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testException()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testException") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testException_presult result;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.err1) {
      completed = true;
      completed__(true);
      throw result.err1;
    }
    completed = true;
    completed__(true);
    return;
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMultiException(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& arg0, const std::string& arg1)
{
  send_testMultiException(arg0, arg1);
  this->channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMultiException(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMultiException") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMultiException_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.err1) {
      completed = true;
      completed__(true);
      throw result.err1;
    }
    if (result.__isset.err2) {
      completed = true;
      completed__(true);
      throw result.err2;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testOneway(::apache::thrift::stdcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
  this->channel_->sendMessage(::apache::thrift::stdcxx::bind(cob, this), this->otrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  this->otrans_->resetBuffer();
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::dispatchCall(::apache::thrift::stdcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second.generic))(cob, seqid, iprot, oprot);
  return;
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::dispatchCallTemplated(::apache::thrift::stdcxx::function<void(bool ok)> cob, Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second.specialized))(cob, seqid, iprot, oprot);
  return;
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testVoid(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testVoid(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testVoid_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testVoid;
  iface_->testVoid(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx));
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testVoid(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testVoid(cob, seqid, _oprot, ctx);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testVoid_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testVoid(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testVoid_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testVoid;
  iface_->testVoid(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx));
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testVoid(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx)
{
  ThriftTest_testVoid_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testString(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testString(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testString_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testString");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testString;
  iface_->testString(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testString(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testString(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testString_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testString(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testString_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testString");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testString;
  iface_->testString(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testString(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return)
{
  ThriftTest_testString_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBool(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testBool(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBool_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBool;
  iface_->testBool(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBool(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testBool(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBool_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBool(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testBool_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBool");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBool", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBool");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const bool& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBool;
  iface_->testBool(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBool(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const bool& _return)
{
  ThriftTest_testBool_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBool", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBool");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBool");
  }

  oprot->writeMessageBegin("testBool", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBool", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testByte(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testByte(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testByte_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int8_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testByte;
  iface_->testByte(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testByte(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int8_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testByte(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testByte_presult result;
  result.success = const_cast<int8_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testByte(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testByte_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int8_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testByte;
  iface_->testByte(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testByte(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int8_t& _return)
{
  ThriftTest_testByte_presult result;
  result.success = const_cast<int8_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI32(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testI32(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI32_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI32;
  iface_->testI32(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI32(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testI32(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI32_presult result;
  result.success = const_cast<int32_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI32(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testI32_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int32_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI32;
  iface_->testI32(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI32(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int32_t& _return)
{
  ThriftTest_testI32_presult result;
  result.success = const_cast<int32_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI64(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testI64(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI64_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int64_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI64;
  iface_->testI64(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI64(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int64_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testI64(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI64_presult result;
  result.success = const_cast<int64_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI64(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testI64_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int64_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI64;
  iface_->testI64(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI64(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int64_t& _return)
{
  ThriftTest_testI64_presult result;
  result.success = const_cast<int64_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testDouble(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testDouble(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testDouble_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testDouble;
  iface_->testDouble(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testDouble(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testDouble(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testDouble_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testDouble(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testDouble_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const double& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testDouble;
  iface_->testDouble(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testDouble(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const double& _return)
{
  ThriftTest_testDouble_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBinary(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testBinary(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBinary_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBinary;
  iface_->testBinary(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBinary(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testBinary(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testBinary_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testBinary(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testBinary_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testBinary");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testBinary", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testBinary");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testBinary;
  iface_->testBinary(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testBinary(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return)
{
  ThriftTest_testBinary_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testBinary", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testBinary");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testBinary");
  }

  oprot->writeMessageBegin("testBinary", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testBinary", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStruct(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testStruct(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStruct_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStruct;
  iface_->testStruct(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStruct(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testStruct(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStruct_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStruct(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testStruct_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStruct;
  iface_->testStruct(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStruct(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testStruct_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testNest(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testNest(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testNest_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct2& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testNest;
  iface_->testNest(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testNest(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct2& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testNest(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testNest_presult result;
  result.success = const_cast<Xtruct2*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testNest(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testNest_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct2& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testNest;
  iface_->testNest(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testNest(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct2& _return)
{
  ThriftTest_testNest_presult result;
  result.success = const_cast<Xtruct2*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMap;
  iface_->testMap(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMap_presult result;
  result.success = const_cast<std::map<int32_t, int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMap;
  iface_->testMap(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, int32_t> & _return)
{
  ThriftTest_testMap_presult result;
  result.success = const_cast<std::map<int32_t, int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStringMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testStringMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStringMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::string> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap;
  iface_->testStringMap(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::string> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testStringMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStringMap_presult result;
  result.success = const_cast<std::map<std::string, std::string> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStringMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testStringMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<std::string, std::string> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap;
  iface_->testStringMap(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<std::string, std::string> & _return)
{
  ThriftTest_testStringMap_presult result;
  result.success = const_cast<std::map<std::string, std::string> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testSet(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testSet(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testSet_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testSet;
  iface_->testSet(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testSet(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testSet(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testSet_presult result;
  result.success = const_cast<std::set<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testSet(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testSet_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::set<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testSet;
  iface_->testSet(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testSet(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::set<int32_t> & _return)
{
  ThriftTest_testSet_presult result;
  result.success = const_cast<std::set<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testList(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testList(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testList_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testList");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testList;
  iface_->testList(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testList(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testList(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testList_presult result;
  result.success = const_cast<std::vector<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testList(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testList_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testList");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::vector<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testList;
  iface_->testList(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testList(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::vector<int32_t> & _return)
{
  ThriftTest_testList_presult result;
  result.success = const_cast<std::vector<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testEnum(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testEnum(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testEnum_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Numberz::type& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testEnum;
  iface_->testEnum(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testEnum(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Numberz::type& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testEnum(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testEnum_presult result;
  result.success = const_cast<Numberz::type*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testEnum(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testEnum_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Numberz::type& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testEnum;
  iface_->testEnum(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testEnum(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Numberz::type& _return)
{
  ThriftTest_testEnum_presult result;
  result.success = const_cast<Numberz::type*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testTypedef(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testTypedef(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testTypedef_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const UserId& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef;
  iface_->testTypedef(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const UserId& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testTypedef(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testTypedef_presult result;
  result.success = const_cast<UserId*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testTypedef(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testTypedef_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const UserId& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef;
  iface_->testTypedef(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const UserId& _return)
{
  ThriftTest_testTypedef_presult result;
  result.success = const_cast<UserId*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMapMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMapMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMapMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap;
  iface_->testMapMap(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.hello);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMapMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMapMap_presult result;
  result.success = const_cast<std::map<int32_t, std::map<int32_t, int32_t> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMapMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMapMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap;
  iface_->testMapMap(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.hello);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{
  ThriftTest_testMapMap_presult result;
  result.success = const_cast<std::map<int32_t, std::map<int32_t, int32_t> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testInsanity(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testInsanity(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testInsanity_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity;
  iface_->testInsanity(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.argument);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testInsanity(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testInsanity_presult result;
  result.success = const_cast<std::map<UserId, std::map<Numberz::type, Insanity> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testInsanity(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testInsanity_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity;
  iface_->testInsanity(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.argument);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{
  ThriftTest_testInsanity_presult result;
  result.success = const_cast<std::map<UserId, std::map<Numberz::type, Insanity> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMulti(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMulti(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMulti_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMulti;
  iface_->testMulti(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.arg0,
      args.arg1,
      args.arg2,
      args.arg3,
      args.arg4,
      args.arg5);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMulti(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMulti(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMulti_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMulti(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMulti_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMulti;
  iface_->testMulti(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.arg0,
      args.arg1,
      args.arg2,
      args.arg3,
      args.arg4,
      args.arg5);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMulti(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testMulti_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testException(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testException;
  iface_->testException(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.arg);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testException(cob, seqid, _oprot, ctx);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testException_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return throw_testException(cob, seqid, _oprot, ctx, _throw);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);


  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  ThriftTest_testException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testException;
  iface_->testException(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.arg);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx)
{
  ThriftTest_testException_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  ThriftTest_testException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMultiException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMultiException(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMultiException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException;
  iface_->testMultiException(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.arg0,
      args.arg1);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMultiException(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMultiException_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return throw_testMultiException(cob, seqid, _oprot, ctx, _throw);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);


  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  ThriftTest_testMultiException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
  catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMultiException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMultiException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException;
  iface_->testMultiException(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.arg0,
      args.arg1);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testMultiException_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  ThriftTest_testMultiException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
  catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testOneway(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testOneway(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  (void) seqid;
  (void) oprot;
  ThriftTest_testOneway_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return cob(false);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }
  freer.unregister();
  iface_->testOneway(::apache::thrift::stdcxx::bind(cob, true)
,
      args.secondsToSleep);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testOneway(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  (void) seqid;
  (void) oprot;
  ThriftTest_testOneway_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return cob(false);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }
  freer.unregister();
  iface_->testOneway(::apache::thrift::stdcxx::bind(cob, true)
,
      args.secondsToSleep);
}

template <class Protocol_>
::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncProcessor > ThriftTestAsyncProcessorFactoryT<Protocol_>::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ThriftTestCobSvIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< ThriftTestCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new ThriftTestAsyncProcessorT<Protocol_>(handler));
  return processor;
}

}} // namespace

#endif
