// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package storage

import (
	"encoding/binary"
	"fmt"

	"github.com/cockroachdb/errors"
)

const (
	// LOBReferenceSize is the fixed size of binary encoded LOB reference (16 bytes)
	LOBReferenceSize = 16

	// MagicLOBReference is the magic number for LOB references: 0xFF 0x00 0xFF 0x00
	// This sequence is extremely rare in all text encodings and binary data
	MagicLOBReference uint32 = 0x00FF00FF

	// LOBFieldID is the fixed field ID used for LOB (Large Object) data in arrow schema.
	// This is a reserved field ID that should not conflict with user-defined field IDs.
	// Note: JSON stats uses field IDs 2000-12000, so we use 13000 to avoid conflicts.
	LOBFieldID int64 = 13000

	// LOBFieldName is the fixed column name used for LOB data in arrow schema.
	LOBFieldName = "text_data"
)

// LOBReference represents a reference to LOB (Large Object) data stored in a separate file.
// It uses a fixed-length binary encoding (16 bytes) with magic number for mixed storage support.
//
// Layout (16 bytes total):
//
//	Bytes 0-3:   Magic (0x00FF00FF for LOB reference)
//	Bytes 4-11:  LobFileID (TSO-allocated LOB file ID)
//	Bytes 12-15: RowOffset (row offset in LOB file)
//
// Mixed storage strategy:
//   - Texts < lob_size_threshold: stored directly (no LOB reference)
//   - Texts >= lob_size_threshold: stored as 16-byte LOB references with magic header
type LOBReference struct {
	Magic     uint32 // Magic number (0x00FF00FF for LOB reference)
	LobFileID uint64 // LOB file ID generated by allocator.Alloc()
	RowOffset uint32 // Row offset in the LOB file
}

func NewLOBReference(lobFileID uint64, rowOffset uint32) *LOBReference {
	return &LOBReference{
		Magic:     MagicLOBReference,
		LobFileID: lobFileID,
		RowOffset: rowOffset,
	}
}

// IsLOBReference checks if the given data is a LOB reference by verifying:
// 1. size is exactly 16 bytes
// 2. first 4 bytes match the magic number
func IsLOBReference(data []byte) bool {
	if len(data) != LOBReferenceSize {
		return false
	}
	magic := binary.LittleEndian.Uint32(data[0:4])
	return magic == MagicLOBReference
}

// EncodeLOBReference encodes a LOB reference to 16 bytes
// format: [Magic:4bytes][LobFileID:8bytes][RowOffset:4bytes]
func EncodeLOBReference(ref *LOBReference) []byte {
	buf := make([]byte, LOBReferenceSize)
	binary.LittleEndian.PutUint32(buf[0:4], ref.Magic)
	binary.LittleEndian.PutUint64(buf[4:12], ref.LobFileID)
	binary.LittleEndian.PutUint32(buf[12:16], ref.RowOffset)
	return buf
}

// DecodeLOBReference decodes a LOB reference from 16 bytes
// returns error if size is not 16 bytes or magic number doesn't match
func DecodeLOBReference(data []byte) (*LOBReference, error) {
	if len(data) != LOBReferenceSize {
		return nil, errors.Newf("invalid LOB reference size: expected %d bytes, got %d bytes", LOBReferenceSize, len(data))
	}

	magic := binary.LittleEndian.Uint32(data[0:4])
	if magic != MagicLOBReference {
		return nil, errors.Newf("invalid LOB reference magic: expected 0x%08X, got 0x%08X", MagicLOBReference, magic)
	}

	return &LOBReference{
		Magic:     magic,
		LobFileID: binary.LittleEndian.Uint64(data[4:12]),
		RowOffset: binary.LittleEndian.Uint32(data[12:16]),
	}, nil
}

func (r *LOBReference) IsValid() bool {
	return r.Magic == MagicLOBReference
}

// DebugString returns a human-readable representation of the LOB reference.
// This is mainly for debugging and logging purposes.
// Format: "lob:0x{magic}:{fileID}:{offset}"
func (r *LOBReference) DebugString() string {
	return fmt.Sprintf("lob:0x%08X:%d:%d", r.Magic, r.LobFileID, r.RowOffset)
}

// ParseDebugString parses a human-readable LOB reference string.
// This is mainly for debugging and testing purposes.
// Format: "lob:0x{magic}:{fileID}:{offset}"
func ParseDebugString(s string) (*LOBReference, error) {
	var magic uint32
	var fileID uint64
	var offset uint32
	n, err := fmt.Sscanf(s, "lob:0x%X:%d:%d", &magic, &fileID, &offset)
	if err != nil || n != 3 {
		return nil, errors.Newf("invalid LOB reference string format: %s", s)
	}
	return &LOBReference{
		Magic:     magic,
		LobFileID: fileID,
		RowOffset: offset,
	}, nil
}
