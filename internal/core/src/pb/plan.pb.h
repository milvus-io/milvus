// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plan.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_plan_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_plan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "schema.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_plan_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_plan_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_plan_2eproto;
namespace milvus {
namespace proto {
namespace plan {
class BinaryExpr;
class BinaryExprDefaultTypeInternal;
extern BinaryExprDefaultTypeInternal _BinaryExpr_default_instance_;
class BinaryRangeExpr;
class BinaryRangeExprDefaultTypeInternal;
extern BinaryRangeExprDefaultTypeInternal _BinaryRangeExpr_default_instance_;
class ColumnInfo;
class ColumnInfoDefaultTypeInternal;
extern ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
class CompareExpr;
class CompareExprDefaultTypeInternal;
extern CompareExprDefaultTypeInternal _CompareExpr_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class GenericValue;
class GenericValueDefaultTypeInternal;
extern GenericValueDefaultTypeInternal _GenericValue_default_instance_;
class PlanNode;
class PlanNodeDefaultTypeInternal;
extern PlanNodeDefaultTypeInternal _PlanNode_default_instance_;
class QueryInfo;
class QueryInfoDefaultTypeInternal;
extern QueryInfoDefaultTypeInternal _QueryInfo_default_instance_;
class TermExpr;
class TermExprDefaultTypeInternal;
extern TermExprDefaultTypeInternal _TermExpr_default_instance_;
class UnaryExpr;
class UnaryExprDefaultTypeInternal;
extern UnaryExprDefaultTypeInternal _UnaryExpr_default_instance_;
class UnaryRangeExpr;
class UnaryRangeExprDefaultTypeInternal;
extern UnaryRangeExprDefaultTypeInternal _UnaryRangeExpr_default_instance_;
class VectorANNS;
class VectorANNSDefaultTypeInternal;
extern VectorANNSDefaultTypeInternal _VectorANNS_default_instance_;
}  // namespace plan
}  // namespace proto
}  // namespace milvus
PROTOBUF_NAMESPACE_OPEN
template<> ::milvus::proto::plan::BinaryExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::BinaryExpr>(Arena*);
template<> ::milvus::proto::plan::BinaryRangeExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::BinaryRangeExpr>(Arena*);
template<> ::milvus::proto::plan::ColumnInfo* Arena::CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(Arena*);
template<> ::milvus::proto::plan::CompareExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::CompareExpr>(Arena*);
template<> ::milvus::proto::plan::Expr* Arena::CreateMaybeMessage<::milvus::proto::plan::Expr>(Arena*);
template<> ::milvus::proto::plan::GenericValue* Arena::CreateMaybeMessage<::milvus::proto::plan::GenericValue>(Arena*);
template<> ::milvus::proto::plan::PlanNode* Arena::CreateMaybeMessage<::milvus::proto::plan::PlanNode>(Arena*);
template<> ::milvus::proto::plan::QueryInfo* Arena::CreateMaybeMessage<::milvus::proto::plan::QueryInfo>(Arena*);
template<> ::milvus::proto::plan::TermExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::TermExpr>(Arena*);
template<> ::milvus::proto::plan::UnaryExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::UnaryExpr>(Arena*);
template<> ::milvus::proto::plan::UnaryRangeExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::UnaryRangeExpr>(Arena*);
template<> ::milvus::proto::plan::VectorANNS* Arena::CreateMaybeMessage<::milvus::proto::plan::VectorANNS>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace milvus {
namespace proto {
namespace plan {

enum UnaryExpr_UnaryOp : int {
  UnaryExpr_UnaryOp_Invalid = 0,
  UnaryExpr_UnaryOp_Not = 1,
  UnaryExpr_UnaryOp_UnaryExpr_UnaryOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UnaryExpr_UnaryOp_UnaryExpr_UnaryOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UnaryExpr_UnaryOp_IsValid(int value);
constexpr UnaryExpr_UnaryOp UnaryExpr_UnaryOp_UnaryOp_MIN = UnaryExpr_UnaryOp_Invalid;
constexpr UnaryExpr_UnaryOp UnaryExpr_UnaryOp_UnaryOp_MAX = UnaryExpr_UnaryOp_Not;
constexpr int UnaryExpr_UnaryOp_UnaryOp_ARRAYSIZE = UnaryExpr_UnaryOp_UnaryOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnaryExpr_UnaryOp_descriptor();
template<typename T>
inline const std::string& UnaryExpr_UnaryOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnaryExpr_UnaryOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnaryExpr_UnaryOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UnaryExpr_UnaryOp_descriptor(), enum_t_value);
}
inline bool UnaryExpr_UnaryOp_Parse(
    const std::string& name, UnaryExpr_UnaryOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnaryExpr_UnaryOp>(
    UnaryExpr_UnaryOp_descriptor(), name, value);
}
enum BinaryExpr_BinaryOp : int {
  BinaryExpr_BinaryOp_Invalid = 0,
  BinaryExpr_BinaryOp_LogicalAnd = 1,
  BinaryExpr_BinaryOp_LogicalOr = 2,
  BinaryExpr_BinaryOp_BinaryExpr_BinaryOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinaryExpr_BinaryOp_BinaryExpr_BinaryOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinaryExpr_BinaryOp_IsValid(int value);
constexpr BinaryExpr_BinaryOp BinaryExpr_BinaryOp_BinaryOp_MIN = BinaryExpr_BinaryOp_Invalid;
constexpr BinaryExpr_BinaryOp BinaryExpr_BinaryOp_BinaryOp_MAX = BinaryExpr_BinaryOp_LogicalOr;
constexpr int BinaryExpr_BinaryOp_BinaryOp_ARRAYSIZE = BinaryExpr_BinaryOp_BinaryOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryExpr_BinaryOp_descriptor();
template<typename T>
inline const std::string& BinaryExpr_BinaryOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryExpr_BinaryOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryExpr_BinaryOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BinaryExpr_BinaryOp_descriptor(), enum_t_value);
}
inline bool BinaryExpr_BinaryOp_Parse(
    const std::string& name, BinaryExpr_BinaryOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BinaryExpr_BinaryOp>(
    BinaryExpr_BinaryOp_descriptor(), name, value);
}
enum OpType : int {
  Invalid = 0,
  GreaterThan = 1,
  GreaterEqual = 2,
  LessThan = 3,
  LessEqual = 4,
  Equal = 5,
  NotEqual = 6,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OpType_IsValid(int value);
constexpr OpType OpType_MIN = Invalid;
constexpr OpType OpType_MAX = NotEqual;
constexpr int OpType_ARRAYSIZE = OpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpType_descriptor();
template<typename T>
inline const std::string& OpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpType_descriptor(), enum_t_value);
}
inline bool OpType_Parse(
    const std::string& name, OpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpType>(
    OpType_descriptor(), name, value);
}
// ===================================================================

class GenericValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.GenericValue) */ {
 public:
  GenericValue();
  virtual ~GenericValue();

  GenericValue(const GenericValue& from);
  GenericValue(GenericValue&& from) noexcept
    : GenericValue() {
    *this = ::std::move(from);
  }

  inline GenericValue& operator=(const GenericValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericValue& operator=(GenericValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenericValue& default_instance();

  enum ValCase {
    kBoolVal = 1,
    kInt64Val = 2,
    kFloatVal = 3,
    VAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericValue* internal_default_instance() {
    return reinterpret_cast<const GenericValue*>(
               &_GenericValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenericValue& a, GenericValue& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericValue* New() const final {
    return CreateMaybeMessage<GenericValue>(nullptr);
  }

  GenericValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericValue& from);
  void MergeFrom(const GenericValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.GenericValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolValFieldNumber = 1,
    kInt64ValFieldNumber = 2,
    kFloatValFieldNumber = 3,
  };
  // bool bool_val = 1;
  private:
  bool has_bool_val() const;
  public:
  void clear_bool_val();
  bool bool_val() const;
  void set_bool_val(bool value);

  // int64 int64_val = 2;
  private:
  bool has_int64_val() const;
  public:
  void clear_int64_val();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_val() const;
  void set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value);

  // double float_val = 3;
  private:
  bool has_float_val() const;
  public:
  void clear_float_val();
  double float_val() const;
  void set_float_val(double value);

  void clear_val();
  ValCase val_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.GenericValue)
 private:
  class _Internal;
  void set_has_bool_val();
  void set_has_int64_val();
  void set_has_float_val();

  inline bool has_val() const;
  inline void clear_has_val();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ValUnion {
    ValUnion() {}
    bool bool_val_;
    ::PROTOBUF_NAMESPACE_ID::int64 int64_val_;
    double float_val_;
  } val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class QueryInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.QueryInfo) */ {
 public:
  QueryInfo();
  virtual ~QueryInfo();

  QueryInfo(const QueryInfo& from);
  QueryInfo(QueryInfo&& from) noexcept
    : QueryInfo() {
    *this = ::std::move(from);
  }

  inline QueryInfo& operator=(const QueryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryInfo& operator=(QueryInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueryInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryInfo* internal_default_instance() {
    return reinterpret_cast<const QueryInfo*>(
               &_QueryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QueryInfo& a, QueryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryInfo* New() const final {
    return CreateMaybeMessage<QueryInfo>(nullptr);
  }

  QueryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryInfo& from);
  void MergeFrom(const QueryInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.QueryInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricTypeFieldNumber = 3,
    kSearchParamsFieldNumber = 4,
    kTopkFieldNumber = 1,
    kRoundDecimalFieldNumber = 5,
  };
  // string metric_type = 3;
  void clear_metric_type();
  const std::string& metric_type() const;
  void set_metric_type(const std::string& value);
  void set_metric_type(std::string&& value);
  void set_metric_type(const char* value);
  void set_metric_type(const char* value, size_t size);
  std::string* mutable_metric_type();
  std::string* release_metric_type();
  void set_allocated_metric_type(std::string* metric_type);

  // string search_params = 4;
  void clear_search_params();
  const std::string& search_params() const;
  void set_search_params(const std::string& value);
  void set_search_params(std::string&& value);
  void set_search_params(const char* value);
  void set_search_params(const char* value, size_t size);
  std::string* mutable_search_params();
  std::string* release_search_params();
  void set_allocated_search_params(std::string* search_params);

  // int64 topk = 1;
  void clear_topk();
  ::PROTOBUF_NAMESPACE_ID::int64 topk() const;
  void set_topk(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 round_decimal = 5;
  void clear_round_decimal();
  ::PROTOBUF_NAMESPACE_ID::int64 round_decimal() const;
  void set_round_decimal(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.QueryInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_params_;
  ::PROTOBUF_NAMESPACE_ID::int64 topk_;
  ::PROTOBUF_NAMESPACE_ID::int64 round_decimal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ColumnInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ColumnInfo) */ {
 public:
  ColumnInfo();
  virtual ~ColumnInfo();

  ColumnInfo(const ColumnInfo& from);
  ColumnInfo(ColumnInfo&& from) noexcept
    : ColumnInfo() {
    *this = ::std::move(from);
  }

  inline ColumnInfo& operator=(const ColumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnInfo& operator=(ColumnInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnInfo*>(
               &_ColumnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ColumnInfo& a, ColumnInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnInfo* New() const final {
    return CreateMaybeMessage<ColumnInfo>(nullptr);
  }

  ColumnInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnInfo& from);
  void MergeFrom(const ColumnInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.ColumnInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldIdFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kIsPrimaryKeyFieldNumber = 3,
    kIsAutoIDFieldNumber = 4,
  };
  // int64 field_id = 1;
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int64 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .milvus.proto.schema.DataType data_type = 2;
  void clear_data_type();
  ::milvus::proto::schema::DataType data_type() const;
  void set_data_type(::milvus::proto::schema::DataType value);

  // bool is_primary_key = 3;
  void clear_is_primary_key();
  bool is_primary_key() const;
  void set_is_primary_key(bool value);

  // bool is_autoID = 4;
  void clear_is_autoid();
  bool is_autoid() const;
  void set_is_autoid(bool value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ColumnInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 field_id_;
  int data_type_;
  bool is_primary_key_;
  bool is_autoid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class UnaryRangeExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.UnaryRangeExpr) */ {
 public:
  UnaryRangeExpr();
  virtual ~UnaryRangeExpr();

  UnaryRangeExpr(const UnaryRangeExpr& from);
  UnaryRangeExpr(UnaryRangeExpr&& from) noexcept
    : UnaryRangeExpr() {
    *this = ::std::move(from);
  }

  inline UnaryRangeExpr& operator=(const UnaryRangeExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryRangeExpr& operator=(UnaryRangeExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnaryRangeExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnaryRangeExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryRangeExpr*>(
               &_UnaryRangeExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UnaryRangeExpr& a, UnaryRangeExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryRangeExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnaryRangeExpr* New() const final {
    return CreateMaybeMessage<UnaryRangeExpr>(nullptr);
  }

  UnaryRangeExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnaryRangeExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnaryRangeExpr& from);
  void MergeFrom(const UnaryRangeExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnaryRangeExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.UnaryRangeExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfoFieldNumber = 1,
    kValueFieldNumber = 3,
    kOpFieldNumber = 2,
  };
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info();
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info);

  // .milvus.proto.plan.GenericValue value = 3;
  bool has_value() const;
  void clear_value();
  const ::milvus::proto::plan::GenericValue& value() const;
  ::milvus::proto::plan::GenericValue* release_value();
  ::milvus::proto::plan::GenericValue* mutable_value();
  void set_allocated_value(::milvus::proto::plan::GenericValue* value);

  // .milvus.proto.plan.OpType op = 2;
  void clear_op();
  ::milvus::proto::plan::OpType op() const;
  void set_op(::milvus::proto::plan::OpType value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.UnaryRangeExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::ColumnInfo* column_info_;
  ::milvus::proto::plan::GenericValue* value_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class BinaryRangeExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryRangeExpr) */ {
 public:
  BinaryRangeExpr();
  virtual ~BinaryRangeExpr();

  BinaryRangeExpr(const BinaryRangeExpr& from);
  BinaryRangeExpr(BinaryRangeExpr&& from) noexcept
    : BinaryRangeExpr() {
    *this = ::std::move(from);
  }

  inline BinaryRangeExpr& operator=(const BinaryRangeExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryRangeExpr& operator=(BinaryRangeExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryRangeExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryRangeExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryRangeExpr*>(
               &_BinaryRangeExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BinaryRangeExpr& a, BinaryRangeExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryRangeExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryRangeExpr* New() const final {
    return CreateMaybeMessage<BinaryRangeExpr>(nullptr);
  }

  BinaryRangeExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryRangeExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryRangeExpr& from);
  void MergeFrom(const BinaryRangeExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryRangeExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.BinaryRangeExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfoFieldNumber = 1,
    kLowerValueFieldNumber = 4,
    kUpperValueFieldNumber = 5,
    kLowerInclusiveFieldNumber = 2,
    kUpperInclusiveFieldNumber = 3,
  };
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info();
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info);

  // .milvus.proto.plan.GenericValue lower_value = 4;
  bool has_lower_value() const;
  void clear_lower_value();
  const ::milvus::proto::plan::GenericValue& lower_value() const;
  ::milvus::proto::plan::GenericValue* release_lower_value();
  ::milvus::proto::plan::GenericValue* mutable_lower_value();
  void set_allocated_lower_value(::milvus::proto::plan::GenericValue* lower_value);

  // .milvus.proto.plan.GenericValue upper_value = 5;
  bool has_upper_value() const;
  void clear_upper_value();
  const ::milvus::proto::plan::GenericValue& upper_value() const;
  ::milvus::proto::plan::GenericValue* release_upper_value();
  ::milvus::proto::plan::GenericValue* mutable_upper_value();
  void set_allocated_upper_value(::milvus::proto::plan::GenericValue* upper_value);

  // bool lower_inclusive = 2;
  void clear_lower_inclusive();
  bool lower_inclusive() const;
  void set_lower_inclusive(bool value);

  // bool upper_inclusive = 3;
  void clear_upper_inclusive();
  bool upper_inclusive() const;
  void set_upper_inclusive(bool value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryRangeExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::ColumnInfo* column_info_;
  ::milvus::proto::plan::GenericValue* lower_value_;
  ::milvus::proto::plan::GenericValue* upper_value_;
  bool lower_inclusive_;
  bool upper_inclusive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class CompareExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.CompareExpr) */ {
 public:
  CompareExpr();
  virtual ~CompareExpr();

  CompareExpr(const CompareExpr& from);
  CompareExpr(CompareExpr&& from) noexcept
    : CompareExpr() {
    *this = ::std::move(from);
  }

  inline CompareExpr& operator=(const CompareExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareExpr& operator=(CompareExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompareExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompareExpr* internal_default_instance() {
    return reinterpret_cast<const CompareExpr*>(
               &_CompareExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CompareExpr& a, CompareExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompareExpr* New() const final {
    return CreateMaybeMessage<CompareExpr>(nullptr);
  }

  CompareExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompareExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompareExpr& from);
  void MergeFrom(const CompareExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.CompareExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftColumnInfoFieldNumber = 1,
    kRightColumnInfoFieldNumber = 2,
    kOpFieldNumber = 3,
  };
  // .milvus.proto.plan.ColumnInfo left_column_info = 1;
  bool has_left_column_info() const;
  void clear_left_column_info();
  const ::milvus::proto::plan::ColumnInfo& left_column_info() const;
  ::milvus::proto::plan::ColumnInfo* release_left_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_left_column_info();
  void set_allocated_left_column_info(::milvus::proto::plan::ColumnInfo* left_column_info);

  // .milvus.proto.plan.ColumnInfo right_column_info = 2;
  bool has_right_column_info() const;
  void clear_right_column_info();
  const ::milvus::proto::plan::ColumnInfo& right_column_info() const;
  ::milvus::proto::plan::ColumnInfo* release_right_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_right_column_info();
  void set_allocated_right_column_info(::milvus::proto::plan::ColumnInfo* right_column_info);

  // .milvus.proto.plan.OpType op = 3;
  void clear_op();
  ::milvus::proto::plan::OpType op() const;
  void set_op(::milvus::proto::plan::OpType value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.CompareExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::ColumnInfo* left_column_info_;
  ::milvus::proto::plan::ColumnInfo* right_column_info_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class TermExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.TermExpr) */ {
 public:
  TermExpr();
  virtual ~TermExpr();

  TermExpr(const TermExpr& from);
  TermExpr(TermExpr&& from) noexcept
    : TermExpr() {
    *this = ::std::move(from);
  }

  inline TermExpr& operator=(const TermExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline TermExpr& operator=(TermExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TermExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TermExpr* internal_default_instance() {
    return reinterpret_cast<const TermExpr*>(
               &_TermExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TermExpr& a, TermExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(TermExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TermExpr* New() const final {
    return CreateMaybeMessage<TermExpr>(nullptr);
  }

  TermExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TermExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TermExpr& from);
  void MergeFrom(const TermExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TermExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.TermExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kColumnInfoFieldNumber = 1,
  };
  // repeated .milvus.proto.plan.GenericValue values = 2;
  int values_size() const;
  void clear_values();
  ::milvus::proto::plan::GenericValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >*
      mutable_values();
  const ::milvus::proto::plan::GenericValue& values(int index) const;
  ::milvus::proto::plan::GenericValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >&
      values() const;

  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info();
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.TermExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue > values_;
  ::milvus::proto::plan::ColumnInfo* column_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class UnaryExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.UnaryExpr) */ {
 public:
  UnaryExpr();
  virtual ~UnaryExpr();

  UnaryExpr(const UnaryExpr& from);
  UnaryExpr(UnaryExpr&& from) noexcept
    : UnaryExpr() {
    *this = ::std::move(from);
  }

  inline UnaryExpr& operator=(const UnaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryExpr& operator=(UnaryExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnaryExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnaryExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryExpr*>(
               &_UnaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnaryExpr& a, UnaryExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnaryExpr* New() const final {
    return CreateMaybeMessage<UnaryExpr>(nullptr);
  }

  UnaryExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnaryExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnaryExpr& from);
  void MergeFrom(const UnaryExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnaryExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.UnaryExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UnaryExpr_UnaryOp UnaryOp;
  static constexpr UnaryOp Invalid =
    UnaryExpr_UnaryOp_Invalid;
  static constexpr UnaryOp Not =
    UnaryExpr_UnaryOp_Not;
  static inline bool UnaryOp_IsValid(int value) {
    return UnaryExpr_UnaryOp_IsValid(value);
  }
  static constexpr UnaryOp UnaryOp_MIN =
    UnaryExpr_UnaryOp_UnaryOp_MIN;
  static constexpr UnaryOp UnaryOp_MAX =
    UnaryExpr_UnaryOp_UnaryOp_MAX;
  static constexpr int UnaryOp_ARRAYSIZE =
    UnaryExpr_UnaryOp_UnaryOp_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UnaryOp_descriptor() {
    return UnaryExpr_UnaryOp_descriptor();
  }
  template<typename T>
  static inline const std::string& UnaryOp_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UnaryOp>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UnaryOp_Name.");
    return UnaryExpr_UnaryOp_Name(enum_t_value);
  }
  static inline bool UnaryOp_Parse(const std::string& name,
      UnaryOp* value) {
    return UnaryExpr_UnaryOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // .milvus.proto.plan.Expr child = 2;
  bool has_child() const;
  void clear_child();
  const ::milvus::proto::plan::Expr& child() const;
  ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* child);

  // .milvus.proto.plan.UnaryExpr.UnaryOp op = 1;
  void clear_op();
  ::milvus::proto::plan::UnaryExpr_UnaryOp op() const;
  void set_op(::milvus::proto::plan::UnaryExpr_UnaryOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.UnaryExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* child_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class BinaryExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryExpr) */ {
 public:
  BinaryExpr();
  virtual ~BinaryExpr();

  BinaryExpr(const BinaryExpr& from);
  BinaryExpr(BinaryExpr&& from) noexcept
    : BinaryExpr() {
    *this = ::std::move(from);
  }

  inline BinaryExpr& operator=(const BinaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryExpr& operator=(BinaryExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryExpr*>(
               &_BinaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BinaryExpr& a, BinaryExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryExpr* New() const final {
    return CreateMaybeMessage<BinaryExpr>(nullptr);
  }

  BinaryExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryExpr& from);
  void MergeFrom(const BinaryExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.BinaryExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BinaryExpr_BinaryOp BinaryOp;
  static constexpr BinaryOp Invalid =
    BinaryExpr_BinaryOp_Invalid;
  static constexpr BinaryOp LogicalAnd =
    BinaryExpr_BinaryOp_LogicalAnd;
  static constexpr BinaryOp LogicalOr =
    BinaryExpr_BinaryOp_LogicalOr;
  static inline bool BinaryOp_IsValid(int value) {
    return BinaryExpr_BinaryOp_IsValid(value);
  }
  static constexpr BinaryOp BinaryOp_MIN =
    BinaryExpr_BinaryOp_BinaryOp_MIN;
  static constexpr BinaryOp BinaryOp_MAX =
    BinaryExpr_BinaryOp_BinaryOp_MAX;
  static constexpr int BinaryOp_ARRAYSIZE =
    BinaryExpr_BinaryOp_BinaryOp_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BinaryOp_descriptor() {
    return BinaryExpr_BinaryOp_descriptor();
  }
  template<typename T>
  static inline const std::string& BinaryOp_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BinaryOp>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BinaryOp_Name.");
    return BinaryExpr_BinaryOp_Name(enum_t_value);
  }
  static inline bool BinaryOp_Parse(const std::string& name,
      BinaryOp* value) {
    return BinaryExpr_BinaryOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kOpFieldNumber = 1,
  };
  // .milvus.proto.plan.Expr left = 2;
  bool has_left() const;
  void clear_left();
  const ::milvus::proto::plan::Expr& left() const;
  ::milvus::proto::plan::Expr* release_left();
  ::milvus::proto::plan::Expr* mutable_left();
  void set_allocated_left(::milvus::proto::plan::Expr* left);

  // .milvus.proto.plan.Expr right = 3;
  bool has_right() const;
  void clear_right();
  const ::milvus::proto::plan::Expr& right() const;
  ::milvus::proto::plan::Expr* release_right();
  ::milvus::proto::plan::Expr* mutable_right();
  void set_allocated_right(::milvus::proto::plan::Expr* right);

  // .milvus.proto.plan.BinaryExpr.BinaryOp op = 1;
  void clear_op();
  ::milvus::proto::plan::BinaryExpr_BinaryOp op() const;
  void set_op(::milvus::proto::plan::BinaryExpr_BinaryOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* left_;
  ::milvus::proto::plan::Expr* right_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class Expr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr& operator=(Expr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Expr& default_instance();

  enum ExprCase {
    kTermExpr = 1,
    kUnaryExpr = 2,
    kBinaryExpr = 3,
    kCompareExpr = 4,
    kUnaryRangeExpr = 5,
    kBinaryRangeExpr = 6,
    EXPR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }
  inline void Swap(Expr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Expr* New() const final {
    return CreateMaybeMessage<Expr>(nullptr);
  }

  Expr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Expr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.Expr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermExprFieldNumber = 1,
    kUnaryExprFieldNumber = 2,
    kBinaryExprFieldNumber = 3,
    kCompareExprFieldNumber = 4,
    kUnaryRangeExprFieldNumber = 5,
    kBinaryRangeExprFieldNumber = 6,
  };
  // .milvus.proto.plan.TermExpr term_expr = 1;
  bool has_term_expr() const;
  void clear_term_expr();
  const ::milvus::proto::plan::TermExpr& term_expr() const;
  ::milvus::proto::plan::TermExpr* release_term_expr();
  ::milvus::proto::plan::TermExpr* mutable_term_expr();
  void set_allocated_term_expr(::milvus::proto::plan::TermExpr* term_expr);

  // .milvus.proto.plan.UnaryExpr unary_expr = 2;
  bool has_unary_expr() const;
  void clear_unary_expr();
  const ::milvus::proto::plan::UnaryExpr& unary_expr() const;
  ::milvus::proto::plan::UnaryExpr* release_unary_expr();
  ::milvus::proto::plan::UnaryExpr* mutable_unary_expr();
  void set_allocated_unary_expr(::milvus::proto::plan::UnaryExpr* unary_expr);

  // .milvus.proto.plan.BinaryExpr binary_expr = 3;
  bool has_binary_expr() const;
  void clear_binary_expr();
  const ::milvus::proto::plan::BinaryExpr& binary_expr() const;
  ::milvus::proto::plan::BinaryExpr* release_binary_expr();
  ::milvus::proto::plan::BinaryExpr* mutable_binary_expr();
  void set_allocated_binary_expr(::milvus::proto::plan::BinaryExpr* binary_expr);

  // .milvus.proto.plan.CompareExpr compare_expr = 4;
  bool has_compare_expr() const;
  void clear_compare_expr();
  const ::milvus::proto::plan::CompareExpr& compare_expr() const;
  ::milvus::proto::plan::CompareExpr* release_compare_expr();
  ::milvus::proto::plan::CompareExpr* mutable_compare_expr();
  void set_allocated_compare_expr(::milvus::proto::plan::CompareExpr* compare_expr);

  // .milvus.proto.plan.UnaryRangeExpr unary_range_expr = 5;
  bool has_unary_range_expr() const;
  void clear_unary_range_expr();
  const ::milvus::proto::plan::UnaryRangeExpr& unary_range_expr() const;
  ::milvus::proto::plan::UnaryRangeExpr* release_unary_range_expr();
  ::milvus::proto::plan::UnaryRangeExpr* mutable_unary_range_expr();
  void set_allocated_unary_range_expr(::milvus::proto::plan::UnaryRangeExpr* unary_range_expr);

  // .milvus.proto.plan.BinaryRangeExpr binary_range_expr = 6;
  bool has_binary_range_expr() const;
  void clear_binary_range_expr();
  const ::milvus::proto::plan::BinaryRangeExpr& binary_range_expr() const;
  ::milvus::proto::plan::BinaryRangeExpr* release_binary_range_expr();
  ::milvus::proto::plan::BinaryRangeExpr* mutable_binary_range_expr();
  void set_allocated_binary_range_expr(::milvus::proto::plan::BinaryRangeExpr* binary_range_expr);

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.Expr)
 private:
  class _Internal;
  void set_has_term_expr();
  void set_has_unary_expr();
  void set_has_binary_expr();
  void set_has_compare_expr();
  void set_has_unary_range_expr();
  void set_has_binary_range_expr();

  inline bool has_expr() const;
  inline void clear_has_expr();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ExprUnion {
    ExprUnion() {}
    ::milvus::proto::plan::TermExpr* term_expr_;
    ::milvus::proto::plan::UnaryExpr* unary_expr_;
    ::milvus::proto::plan::BinaryExpr* binary_expr_;
    ::milvus::proto::plan::CompareExpr* compare_expr_;
    ::milvus::proto::plan::UnaryRangeExpr* unary_range_expr_;
    ::milvus::proto::plan::BinaryRangeExpr* binary_range_expr_;
  } expr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class VectorANNS :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.VectorANNS) */ {
 public:
  VectorANNS();
  virtual ~VectorANNS();

  VectorANNS(const VectorANNS& from);
  VectorANNS(VectorANNS&& from) noexcept
    : VectorANNS() {
    *this = ::std::move(from);
  }

  inline VectorANNS& operator=(const VectorANNS& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorANNS& operator=(VectorANNS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VectorANNS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorANNS* internal_default_instance() {
    return reinterpret_cast<const VectorANNS*>(
               &_VectorANNS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VectorANNS& a, VectorANNS& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorANNS* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorANNS* New() const final {
    return CreateMaybeMessage<VectorANNS>(nullptr);
  }

  VectorANNS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorANNS>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VectorANNS& from);
  void MergeFrom(const VectorANNS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorANNS* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.VectorANNS";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaceholderTagFieldNumber = 5,
    kPredicatesFieldNumber = 3,
    kQueryInfoFieldNumber = 4,
    kFieldIdFieldNumber = 2,
    kIsBinaryFieldNumber = 1,
  };
  // string placeholder_tag = 5;
  void clear_placeholder_tag();
  const std::string& placeholder_tag() const;
  void set_placeholder_tag(const std::string& value);
  void set_placeholder_tag(std::string&& value);
  void set_placeholder_tag(const char* value);
  void set_placeholder_tag(const char* value, size_t size);
  std::string* mutable_placeholder_tag();
  std::string* release_placeholder_tag();
  void set_allocated_placeholder_tag(std::string* placeholder_tag);

  // .milvus.proto.plan.Expr predicates = 3;
  bool has_predicates() const;
  void clear_predicates();
  const ::milvus::proto::plan::Expr& predicates() const;
  ::milvus::proto::plan::Expr* release_predicates();
  ::milvus::proto::plan::Expr* mutable_predicates();
  void set_allocated_predicates(::milvus::proto::plan::Expr* predicates);

  // .milvus.proto.plan.QueryInfo query_info = 4;
  bool has_query_info() const;
  void clear_query_info();
  const ::milvus::proto::plan::QueryInfo& query_info() const;
  ::milvus::proto::plan::QueryInfo* release_query_info();
  ::milvus::proto::plan::QueryInfo* mutable_query_info();
  void set_allocated_query_info(::milvus::proto::plan::QueryInfo* query_info);

  // int64 field_id = 2;
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int64 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // bool is_binary = 1;
  void clear_is_binary();
  bool is_binary() const;
  void set_is_binary(bool value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.VectorANNS)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placeholder_tag_;
  ::milvus::proto::plan::Expr* predicates_;
  ::milvus::proto::plan::QueryInfo* query_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 field_id_;
  bool is_binary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PlanNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.PlanNode) */ {
 public:
  PlanNode();
  virtual ~PlanNode();

  PlanNode(const PlanNode& from);
  PlanNode(PlanNode&& from) noexcept
    : PlanNode() {
    *this = ::std::move(from);
  }

  inline PlanNode& operator=(const PlanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanNode& operator=(PlanNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlanNode& default_instance();

  enum NodeCase {
    kVectorAnns = 1,
    kPredicates = 2,
    NODE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanNode* internal_default_instance() {
    return reinterpret_cast<const PlanNode*>(
               &_PlanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PlanNode& a, PlanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanNode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlanNode* New() const final {
    return CreateMaybeMessage<PlanNode>(nullptr);
  }

  PlanNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlanNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlanNode& from);
  void MergeFrom(const PlanNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.PlanNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldIdsFieldNumber = 3,
    kVectorAnnsFieldNumber = 1,
    kPredicatesFieldNumber = 2,
  };
  // repeated int64 output_field_ids = 3;
  int output_field_ids_size() const;
  void clear_output_field_ids();
  ::PROTOBUF_NAMESPACE_ID::int64 output_field_ids(int index) const;
  void set_output_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_output_field_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      output_field_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_output_field_ids();

  // .milvus.proto.plan.VectorANNS vector_anns = 1;
  bool has_vector_anns() const;
  void clear_vector_anns();
  const ::milvus::proto::plan::VectorANNS& vector_anns() const;
  ::milvus::proto::plan::VectorANNS* release_vector_anns();
  ::milvus::proto::plan::VectorANNS* mutable_vector_anns();
  void set_allocated_vector_anns(::milvus::proto::plan::VectorANNS* vector_anns);

  // .milvus.proto.plan.Expr predicates = 2;
  bool has_predicates() const;
  void clear_predicates();
  const ::milvus::proto::plan::Expr& predicates() const;
  ::milvus::proto::plan::Expr* release_predicates();
  ::milvus::proto::plan::Expr* mutable_predicates();
  void set_allocated_predicates(::milvus::proto::plan::Expr* predicates);

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.PlanNode)
 private:
  class _Internal;
  void set_has_vector_anns();
  void set_has_predicates();

  inline bool has_node() const;
  inline void clear_has_node();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > output_field_ids_;
  mutable std::atomic<int> _output_field_ids_cached_byte_size_;
  union NodeUnion {
    NodeUnion() {}
    ::milvus::proto::plan::VectorANNS* vector_anns_;
    ::milvus::proto::plan::Expr* predicates_;
  } node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_plan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GenericValue

// bool bool_val = 1;
inline bool GenericValue::has_bool_val() const {
  return val_case() == kBoolVal;
}
inline void GenericValue::set_has_bool_val() {
  _oneof_case_[0] = kBoolVal;
}
inline void GenericValue::clear_bool_val() {
  if (has_bool_val()) {
    val_.bool_val_ = false;
    clear_has_val();
  }
}
inline bool GenericValue::bool_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.bool_val)
  if (has_bool_val()) {
    return val_.bool_val_;
  }
  return false;
}
inline void GenericValue::set_bool_val(bool value) {
  if (!has_bool_val()) {
    clear_val();
    set_has_bool_val();
  }
  val_.bool_val_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.bool_val)
}

// int64 int64_val = 2;
inline bool GenericValue::has_int64_val() const {
  return val_case() == kInt64Val;
}
inline void GenericValue::set_has_int64_val() {
  _oneof_case_[0] = kInt64Val;
}
inline void GenericValue::clear_int64_val() {
  if (has_int64_val()) {
    val_.int64_val_ = PROTOBUF_LONGLONG(0);
    clear_has_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GenericValue::int64_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.int64_val)
  if (has_int64_val()) {
    return val_.int64_val_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void GenericValue::set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!has_int64_val()) {
    clear_val();
    set_has_int64_val();
  }
  val_.int64_val_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.int64_val)
}

// double float_val = 3;
inline bool GenericValue::has_float_val() const {
  return val_case() == kFloatVal;
}
inline void GenericValue::set_has_float_val() {
  _oneof_case_[0] = kFloatVal;
}
inline void GenericValue::clear_float_val() {
  if (has_float_val()) {
    val_.float_val_ = 0;
    clear_has_val();
  }
}
inline double GenericValue::float_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.float_val)
  if (has_float_val()) {
    return val_.float_val_;
  }
  return 0;
}
inline void GenericValue::set_float_val(double value) {
  if (!has_float_val()) {
    clear_val();
    set_has_float_val();
  }
  val_.float_val_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.float_val)
}

inline bool GenericValue::has_val() const {
  return val_case() != VAL_NOT_SET;
}
inline void GenericValue::clear_has_val() {
  _oneof_case_[0] = VAL_NOT_SET;
}
inline GenericValue::ValCase GenericValue::val_case() const {
  return GenericValue::ValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// QueryInfo

// int64 topk = 1;
inline void QueryInfo::clear_topk() {
  topk_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInfo::topk() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.topk)
  return topk_;
}
inline void QueryInfo::set_topk(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  topk_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.topk)
}

// string metric_type = 3;
inline void QueryInfo::clear_metric_type() {
  metric_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& QueryInfo::metric_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.metric_type)
  return metric_type_.GetNoArena();
}
inline void QueryInfo::set_metric_type(const std::string& value) {
  
  metric_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.metric_type)
}
inline void QueryInfo::set_metric_type(std::string&& value) {
  
  metric_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:milvus.proto.plan.QueryInfo.metric_type)
}
inline void QueryInfo::set_metric_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  metric_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:milvus.proto.plan.QueryInfo.metric_type)
}
inline void QueryInfo::set_metric_type(const char* value, size_t size) {
  
  metric_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.plan.QueryInfo.metric_type)
}
inline std::string* QueryInfo::mutable_metric_type() {
  
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.QueryInfo.metric_type)
  return metric_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* QueryInfo::release_metric_type() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.QueryInfo.metric_type)
  
  return metric_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void QueryInfo::set_allocated_metric_type(std::string* metric_type) {
  if (metric_type != nullptr) {
    
  } else {
    
  }
  metric_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metric_type);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.QueryInfo.metric_type)
}

// string search_params = 4;
inline void QueryInfo::clear_search_params() {
  search_params_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& QueryInfo::search_params() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.search_params)
  return search_params_.GetNoArena();
}
inline void QueryInfo::set_search_params(const std::string& value) {
  
  search_params_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.search_params)
}
inline void QueryInfo::set_search_params(std::string&& value) {
  
  search_params_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:milvus.proto.plan.QueryInfo.search_params)
}
inline void QueryInfo::set_search_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  search_params_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:milvus.proto.plan.QueryInfo.search_params)
}
inline void QueryInfo::set_search_params(const char* value, size_t size) {
  
  search_params_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.plan.QueryInfo.search_params)
}
inline std::string* QueryInfo::mutable_search_params() {
  
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.QueryInfo.search_params)
  return search_params_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* QueryInfo::release_search_params() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.QueryInfo.search_params)
  
  return search_params_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void QueryInfo::set_allocated_search_params(std::string* search_params) {
  if (search_params != nullptr) {
    
  } else {
    
  }
  search_params_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), search_params);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.QueryInfo.search_params)
}

// int64 round_decimal = 5;
inline void QueryInfo::clear_round_decimal() {
  round_decimal_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInfo::round_decimal() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.round_decimal)
  return round_decimal_;
}
inline void QueryInfo::set_round_decimal(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  round_decimal_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.round_decimal)
}

// -------------------------------------------------------------------

// ColumnInfo

// int64 field_id = 1;
inline void ColumnInfo::clear_field_id() {
  field_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ColumnInfo::field_id() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.field_id)
  return field_id_;
}
inline void ColumnInfo::set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  field_id_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.field_id)
}

// .milvus.proto.schema.DataType data_type = 2;
inline void ColumnInfo::clear_data_type() {
  data_type_ = 0;
}
inline ::milvus::proto::schema::DataType ColumnInfo::data_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.data_type)
  return static_cast< ::milvus::proto::schema::DataType >(data_type_);
}
inline void ColumnInfo::set_data_type(::milvus::proto::schema::DataType value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.data_type)
}

// bool is_primary_key = 3;
inline void ColumnInfo::clear_is_primary_key() {
  is_primary_key_ = false;
}
inline bool ColumnInfo::is_primary_key() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.is_primary_key)
  return is_primary_key_;
}
inline void ColumnInfo::set_is_primary_key(bool value) {
  
  is_primary_key_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.is_primary_key)
}

// bool is_autoID = 4;
inline void ColumnInfo::clear_is_autoid() {
  is_autoid_ = false;
}
inline bool ColumnInfo::is_autoid() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.is_autoID)
  return is_autoid_;
}
inline void ColumnInfo::set_is_autoid(bool value) {
  
  is_autoid_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.is_autoID)
}

// -------------------------------------------------------------------

// UnaryRangeExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool UnaryRangeExpr::has_column_info() const {
  return this != internal_default_instance() && column_info_ != nullptr;
}
inline void UnaryRangeExpr::clear_column_info() {
  if (GetArenaNoVirtual() == nullptr && column_info_ != nullptr) {
    delete column_info_;
  }
  column_info_ = nullptr;
}
inline const ::milvus::proto::plan::ColumnInfo& UnaryRangeExpr::column_info() const {
  const ::milvus::proto::plan::ColumnInfo* p = column_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.column_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::ColumnInfo*>(
      &::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline ::milvus::proto::plan::ColumnInfo* UnaryRangeExpr::release_column_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryRangeExpr.column_info)
  
  ::milvus::proto::plan::ColumnInfo* temp = column_info_;
  column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* UnaryRangeExpr::mutable_column_info() {
  
  if (column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArenaNoVirtual());
    column_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryRangeExpr.column_info)
  return column_info_;
}
inline void UnaryRangeExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete column_info_;
  }
  if (column_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      column_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_info, submessage_arena);
    }
    
  } else {
    
  }
  column_info_ = column_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryRangeExpr.column_info)
}

// .milvus.proto.plan.OpType op = 2;
inline void UnaryRangeExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::OpType UnaryRangeExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.op)
  return static_cast< ::milvus::proto::plan::OpType >(op_);
}
inline void UnaryRangeExpr::set_op(::milvus::proto::plan::OpType value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.UnaryRangeExpr.op)
}

// .milvus.proto.plan.GenericValue value = 3;
inline bool UnaryRangeExpr::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline void UnaryRangeExpr::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::milvus::proto::plan::GenericValue& UnaryRangeExpr::value() const {
  const ::milvus::proto::plan::GenericValue* p = value_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::GenericValue*>(
      &::milvus::proto::plan::_GenericValue_default_instance_);
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::release_value() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryRangeExpr.value)
  
  ::milvus::proto::plan::GenericValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryRangeExpr.value)
  return value_;
}
inline void UnaryRangeExpr::set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryRangeExpr.value)
}

// -------------------------------------------------------------------

// BinaryRangeExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool BinaryRangeExpr::has_column_info() const {
  return this != internal_default_instance() && column_info_ != nullptr;
}
inline void BinaryRangeExpr::clear_column_info() {
  if (GetArenaNoVirtual() == nullptr && column_info_ != nullptr) {
    delete column_info_;
  }
  column_info_ = nullptr;
}
inline const ::milvus::proto::plan::ColumnInfo& BinaryRangeExpr::column_info() const {
  const ::milvus::proto::plan::ColumnInfo* p = column_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.column_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::ColumnInfo*>(
      &::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline ::milvus::proto::plan::ColumnInfo* BinaryRangeExpr::release_column_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.column_info)
  
  ::milvus::proto::plan::ColumnInfo* temp = column_info_;
  column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryRangeExpr::mutable_column_info() {
  
  if (column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArenaNoVirtual());
    column_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.column_info)
  return column_info_;
}
inline void BinaryRangeExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete column_info_;
  }
  if (column_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      column_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_info, submessage_arena);
    }
    
  } else {
    
  }
  column_info_ = column_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.column_info)
}

// bool lower_inclusive = 2;
inline void BinaryRangeExpr::clear_lower_inclusive() {
  lower_inclusive_ = false;
}
inline bool BinaryRangeExpr::lower_inclusive() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.lower_inclusive)
  return lower_inclusive_;
}
inline void BinaryRangeExpr::set_lower_inclusive(bool value) {
  
  lower_inclusive_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryRangeExpr.lower_inclusive)
}

// bool upper_inclusive = 3;
inline void BinaryRangeExpr::clear_upper_inclusive() {
  upper_inclusive_ = false;
}
inline bool BinaryRangeExpr::upper_inclusive() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.upper_inclusive)
  return upper_inclusive_;
}
inline void BinaryRangeExpr::set_upper_inclusive(bool value) {
  
  upper_inclusive_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryRangeExpr.upper_inclusive)
}

// .milvus.proto.plan.GenericValue lower_value = 4;
inline bool BinaryRangeExpr::has_lower_value() const {
  return this != internal_default_instance() && lower_value_ != nullptr;
}
inline void BinaryRangeExpr::clear_lower_value() {
  if (GetArenaNoVirtual() == nullptr && lower_value_ != nullptr) {
    delete lower_value_;
  }
  lower_value_ = nullptr;
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::lower_value() const {
  const ::milvus::proto::plan::GenericValue* p = lower_value_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.lower_value)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::GenericValue*>(
      &::milvus::proto::plan::_GenericValue_default_instance_);
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::release_lower_value() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.lower_value)
  
  ::milvus::proto::plan::GenericValue* temp = lower_value_;
  lower_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::mutable_lower_value() {
  
  if (lower_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArenaNoVirtual());
    lower_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.lower_value)
  return lower_value_;
}
inline void BinaryRangeExpr::set_allocated_lower_value(::milvus::proto::plan::GenericValue* lower_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lower_value_;
  }
  if (lower_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lower_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lower_value, submessage_arena);
    }
    
  } else {
    
  }
  lower_value_ = lower_value;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.lower_value)
}

// .milvus.proto.plan.GenericValue upper_value = 5;
inline bool BinaryRangeExpr::has_upper_value() const {
  return this != internal_default_instance() && upper_value_ != nullptr;
}
inline void BinaryRangeExpr::clear_upper_value() {
  if (GetArenaNoVirtual() == nullptr && upper_value_ != nullptr) {
    delete upper_value_;
  }
  upper_value_ = nullptr;
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::upper_value() const {
  const ::milvus::proto::plan::GenericValue* p = upper_value_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.upper_value)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::GenericValue*>(
      &::milvus::proto::plan::_GenericValue_default_instance_);
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::release_upper_value() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.upper_value)
  
  ::milvus::proto::plan::GenericValue* temp = upper_value_;
  upper_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::mutable_upper_value() {
  
  if (upper_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArenaNoVirtual());
    upper_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.upper_value)
  return upper_value_;
}
inline void BinaryRangeExpr::set_allocated_upper_value(::milvus::proto::plan::GenericValue* upper_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete upper_value_;
  }
  if (upper_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      upper_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upper_value, submessage_arena);
    }
    
  } else {
    
  }
  upper_value_ = upper_value;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.upper_value)
}

// -------------------------------------------------------------------

// CompareExpr

// .milvus.proto.plan.ColumnInfo left_column_info = 1;
inline bool CompareExpr::has_left_column_info() const {
  return this != internal_default_instance() && left_column_info_ != nullptr;
}
inline void CompareExpr::clear_left_column_info() {
  if (GetArenaNoVirtual() == nullptr && left_column_info_ != nullptr) {
    delete left_column_info_;
  }
  left_column_info_ = nullptr;
}
inline const ::milvus::proto::plan::ColumnInfo& CompareExpr::left_column_info() const {
  const ::milvus::proto::plan::ColumnInfo* p = left_column_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.left_column_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::ColumnInfo*>(
      &::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::release_left_column_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.CompareExpr.left_column_info)
  
  ::milvus::proto::plan::ColumnInfo* temp = left_column_info_;
  left_column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::mutable_left_column_info() {
  
  if (left_column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArenaNoVirtual());
    left_column_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.CompareExpr.left_column_info)
  return left_column_info_;
}
inline void CompareExpr::set_allocated_left_column_info(::milvus::proto::plan::ColumnInfo* left_column_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_column_info_;
  }
  if (left_column_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left_column_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_column_info, submessage_arena);
    }
    
  } else {
    
  }
  left_column_info_ = left_column_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.CompareExpr.left_column_info)
}

// .milvus.proto.plan.ColumnInfo right_column_info = 2;
inline bool CompareExpr::has_right_column_info() const {
  return this != internal_default_instance() && right_column_info_ != nullptr;
}
inline void CompareExpr::clear_right_column_info() {
  if (GetArenaNoVirtual() == nullptr && right_column_info_ != nullptr) {
    delete right_column_info_;
  }
  right_column_info_ = nullptr;
}
inline const ::milvus::proto::plan::ColumnInfo& CompareExpr::right_column_info() const {
  const ::milvus::proto::plan::ColumnInfo* p = right_column_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.right_column_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::ColumnInfo*>(
      &::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::release_right_column_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.CompareExpr.right_column_info)
  
  ::milvus::proto::plan::ColumnInfo* temp = right_column_info_;
  right_column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::mutable_right_column_info() {
  
  if (right_column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArenaNoVirtual());
    right_column_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.CompareExpr.right_column_info)
  return right_column_info_;
}
inline void CompareExpr::set_allocated_right_column_info(::milvus::proto::plan::ColumnInfo* right_column_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_column_info_;
  }
  if (right_column_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right_column_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_column_info, submessage_arena);
    }
    
  } else {
    
  }
  right_column_info_ = right_column_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.CompareExpr.right_column_info)
}

// .milvus.proto.plan.OpType op = 3;
inline void CompareExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::OpType CompareExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.op)
  return static_cast< ::milvus::proto::plan::OpType >(op_);
}
inline void CompareExpr::set_op(::milvus::proto::plan::OpType value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.CompareExpr.op)
}

// -------------------------------------------------------------------

// TermExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool TermExpr::has_column_info() const {
  return this != internal_default_instance() && column_info_ != nullptr;
}
inline void TermExpr::clear_column_info() {
  if (GetArenaNoVirtual() == nullptr && column_info_ != nullptr) {
    delete column_info_;
  }
  column_info_ = nullptr;
}
inline const ::milvus::proto::plan::ColumnInfo& TermExpr::column_info() const {
  const ::milvus::proto::plan::ColumnInfo* p = column_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.TermExpr.column_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::ColumnInfo*>(
      &::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline ::milvus::proto::plan::ColumnInfo* TermExpr::release_column_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.TermExpr.column_info)
  
  ::milvus::proto::plan::ColumnInfo* temp = column_info_;
  column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* TermExpr::mutable_column_info() {
  
  if (column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArenaNoVirtual());
    column_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.TermExpr.column_info)
  return column_info_;
}
inline void TermExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete column_info_;
  }
  if (column_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      column_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_info, submessage_arena);
    }
    
  } else {
    
  }
  column_info_ = column_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.TermExpr.column_info)
}

// repeated .milvus.proto.plan.GenericValue values = 2;
inline int TermExpr::values_size() const {
  return values_.size();
}
inline void TermExpr::clear_values() {
  values_.Clear();
}
inline ::milvus::proto::plan::GenericValue* TermExpr::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.TermExpr.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >*
TermExpr::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.TermExpr.values)
  return &values_;
}
inline const ::milvus::proto::plan::GenericValue& TermExpr::values(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.TermExpr.values)
  return values_.Get(index);
}
inline ::milvus::proto::plan::GenericValue* TermExpr::add_values() {
  // @@protoc_insertion_point(field_add:milvus.proto.plan.TermExpr.values)
  return values_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >&
TermExpr::values() const {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.TermExpr.values)
  return values_;
}

// -------------------------------------------------------------------

// UnaryExpr

// .milvus.proto.plan.UnaryExpr.UnaryOp op = 1;
inline void UnaryExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::UnaryExpr_UnaryOp UnaryExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryExpr.op)
  return static_cast< ::milvus::proto::plan::UnaryExpr_UnaryOp >(op_);
}
inline void UnaryExpr::set_op(::milvus::proto::plan::UnaryExpr_UnaryOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.UnaryExpr.op)
}

// .milvus.proto.plan.Expr child = 2;
inline bool UnaryExpr::has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline void UnaryExpr::clear_child() {
  if (GetArenaNoVirtual() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& UnaryExpr::child() const {
  const ::milvus::proto::plan::Expr* p = child_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryExpr.child)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* UnaryExpr::release_child() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryExpr.child)
  
  ::milvus::proto::plan::Expr* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* UnaryExpr::mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryExpr.child)
  return child_;
}
inline void UnaryExpr::set_allocated_child(::milvus::proto::plan::Expr* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryExpr.child)
}

// -------------------------------------------------------------------

// BinaryExpr

// .milvus.proto.plan.BinaryExpr.BinaryOp op = 1;
inline void BinaryExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::BinaryExpr_BinaryOp BinaryExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryExpr.op)
  return static_cast< ::milvus::proto::plan::BinaryExpr_BinaryOp >(op_);
}
inline void BinaryExpr::set_op(::milvus::proto::plan::BinaryExpr_BinaryOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryExpr.op)
}

// .milvus.proto.plan.Expr left = 2;
inline bool BinaryExpr::has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline void BinaryExpr::clear_left() {
  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& BinaryExpr::left() const {
  const ::milvus::proto::plan::Expr* p = left_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryExpr.left)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* BinaryExpr::release_left() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryExpr.left)
  
  ::milvus::proto::plan::Expr* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryExpr.left)
  return left_;
}
inline void BinaryExpr::set_allocated_left(::milvus::proto::plan::Expr* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryExpr.left)
}

// .milvus.proto.plan.Expr right = 3;
inline bool BinaryExpr::has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline void BinaryExpr::clear_right() {
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& BinaryExpr::right() const {
  const ::milvus::proto::plan::Expr* p = right_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryExpr.right)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* BinaryExpr::release_right() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryExpr.right)
  
  ::milvus::proto::plan::Expr* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryExpr.right)
  return right_;
}
inline void BinaryExpr::set_allocated_right(::milvus::proto::plan::Expr* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryExpr.right)
}

// -------------------------------------------------------------------

// Expr

// .milvus.proto.plan.TermExpr term_expr = 1;
inline bool Expr::has_term_expr() const {
  return expr_case() == kTermExpr;
}
inline void Expr::set_has_term_expr() {
  _oneof_case_[0] = kTermExpr;
}
inline void Expr::clear_term_expr() {
  if (has_term_expr()) {
    delete expr_.term_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::TermExpr* Expr::release_term_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.term_expr)
  if (has_term_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::TermExpr* temp = expr_.term_expr_;
    expr_.term_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::TermExpr& Expr::term_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.term_expr)
  return has_term_expr()
      ? *expr_.term_expr_
      : *reinterpret_cast< ::milvus::proto::plan::TermExpr*>(&::milvus::proto::plan::_TermExpr_default_instance_);
}
inline ::milvus::proto::plan::TermExpr* Expr::mutable_term_expr() {
  if (!has_term_expr()) {
    clear_expr();
    set_has_term_expr();
    expr_.term_expr_ = CreateMaybeMessage< ::milvus::proto::plan::TermExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.term_expr)
  return expr_.term_expr_;
}

// .milvus.proto.plan.UnaryExpr unary_expr = 2;
inline bool Expr::has_unary_expr() const {
  return expr_case() == kUnaryExpr;
}
inline void Expr::set_has_unary_expr() {
  _oneof_case_[0] = kUnaryExpr;
}
inline void Expr::clear_unary_expr() {
  if (has_unary_expr()) {
    delete expr_.unary_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::UnaryExpr* Expr::release_unary_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.unary_expr)
  if (has_unary_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::UnaryExpr* temp = expr_.unary_expr_;
    expr_.unary_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::UnaryExpr& Expr::unary_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.unary_expr)
  return has_unary_expr()
      ? *expr_.unary_expr_
      : *reinterpret_cast< ::milvus::proto::plan::UnaryExpr*>(&::milvus::proto::plan::_UnaryExpr_default_instance_);
}
inline ::milvus::proto::plan::UnaryExpr* Expr::mutable_unary_expr() {
  if (!has_unary_expr()) {
    clear_expr();
    set_has_unary_expr();
    expr_.unary_expr_ = CreateMaybeMessage< ::milvus::proto::plan::UnaryExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.unary_expr)
  return expr_.unary_expr_;
}

// .milvus.proto.plan.BinaryExpr binary_expr = 3;
inline bool Expr::has_binary_expr() const {
  return expr_case() == kBinaryExpr;
}
inline void Expr::set_has_binary_expr() {
  _oneof_case_[0] = kBinaryExpr;
}
inline void Expr::clear_binary_expr() {
  if (has_binary_expr()) {
    delete expr_.binary_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryExpr* Expr::release_binary_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_expr)
  if (has_binary_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::BinaryExpr* temp = expr_.binary_expr_;
    expr_.binary_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryExpr& Expr::binary_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_expr)
  return has_binary_expr()
      ? *expr_.binary_expr_
      : *reinterpret_cast< ::milvus::proto::plan::BinaryExpr*>(&::milvus::proto::plan::_BinaryExpr_default_instance_);
}
inline ::milvus::proto::plan::BinaryExpr* Expr::mutable_binary_expr() {
  if (!has_binary_expr()) {
    clear_expr();
    set_has_binary_expr();
    expr_.binary_expr_ = CreateMaybeMessage< ::milvus::proto::plan::BinaryExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_expr)
  return expr_.binary_expr_;
}

// .milvus.proto.plan.CompareExpr compare_expr = 4;
inline bool Expr::has_compare_expr() const {
  return expr_case() == kCompareExpr;
}
inline void Expr::set_has_compare_expr() {
  _oneof_case_[0] = kCompareExpr;
}
inline void Expr::clear_compare_expr() {
  if (has_compare_expr()) {
    delete expr_.compare_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::CompareExpr* Expr::release_compare_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.compare_expr)
  if (has_compare_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::CompareExpr* temp = expr_.compare_expr_;
    expr_.compare_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::CompareExpr& Expr::compare_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.compare_expr)
  return has_compare_expr()
      ? *expr_.compare_expr_
      : *reinterpret_cast< ::milvus::proto::plan::CompareExpr*>(&::milvus::proto::plan::_CompareExpr_default_instance_);
}
inline ::milvus::proto::plan::CompareExpr* Expr::mutable_compare_expr() {
  if (!has_compare_expr()) {
    clear_expr();
    set_has_compare_expr();
    expr_.compare_expr_ = CreateMaybeMessage< ::milvus::proto::plan::CompareExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.compare_expr)
  return expr_.compare_expr_;
}

// .milvus.proto.plan.UnaryRangeExpr unary_range_expr = 5;
inline bool Expr::has_unary_range_expr() const {
  return expr_case() == kUnaryRangeExpr;
}
inline void Expr::set_has_unary_range_expr() {
  _oneof_case_[0] = kUnaryRangeExpr;
}
inline void Expr::clear_unary_range_expr() {
  if (has_unary_range_expr()) {
    delete expr_.unary_range_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::release_unary_range_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.unary_range_expr)
  if (has_unary_range_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::UnaryRangeExpr* temp = expr_.unary_range_expr_;
    expr_.unary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::UnaryRangeExpr& Expr::unary_range_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.unary_range_expr)
  return has_unary_range_expr()
      ? *expr_.unary_range_expr_
      : *reinterpret_cast< ::milvus::proto::plan::UnaryRangeExpr*>(&::milvus::proto::plan::_UnaryRangeExpr_default_instance_);
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::mutable_unary_range_expr() {
  if (!has_unary_range_expr()) {
    clear_expr();
    set_has_unary_range_expr();
    expr_.unary_range_expr_ = CreateMaybeMessage< ::milvus::proto::plan::UnaryRangeExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.unary_range_expr)
  return expr_.unary_range_expr_;
}

// .milvus.proto.plan.BinaryRangeExpr binary_range_expr = 6;
inline bool Expr::has_binary_range_expr() const {
  return expr_case() == kBinaryRangeExpr;
}
inline void Expr::set_has_binary_range_expr() {
  _oneof_case_[0] = kBinaryRangeExpr;
}
inline void Expr::clear_binary_range_expr() {
  if (has_binary_range_expr()) {
    delete expr_.binary_range_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::release_binary_range_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_range_expr)
  if (has_binary_range_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::BinaryRangeExpr* temp = expr_.binary_range_expr_;
    expr_.binary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryRangeExpr& Expr::binary_range_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_range_expr)
  return has_binary_range_expr()
      ? *expr_.binary_range_expr_
      : *reinterpret_cast< ::milvus::proto::plan::BinaryRangeExpr*>(&::milvus::proto::plan::_BinaryRangeExpr_default_instance_);
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::mutable_binary_range_expr() {
  if (!has_binary_range_expr()) {
    clear_expr();
    set_has_binary_range_expr();
    expr_.binary_range_expr_ = CreateMaybeMessage< ::milvus::proto::plan::BinaryRangeExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_range_expr)
  return expr_.binary_range_expr_;
}

inline bool Expr::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void Expr::clear_has_expr() {
  _oneof_case_[0] = EXPR_NOT_SET;
}
inline Expr::ExprCase Expr::expr_case() const {
  return Expr::ExprCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorANNS

// bool is_binary = 1;
inline void VectorANNS::clear_is_binary() {
  is_binary_ = false;
}
inline bool VectorANNS::is_binary() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.is_binary)
  return is_binary_;
}
inline void VectorANNS::set_is_binary(bool value) {
  
  is_binary_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.is_binary)
}

// int64 field_id = 2;
inline void VectorANNS::clear_field_id() {
  field_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VectorANNS::field_id() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.field_id)
  return field_id_;
}
inline void VectorANNS::set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  field_id_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.field_id)
}

// .milvus.proto.plan.Expr predicates = 3;
inline bool VectorANNS::has_predicates() const {
  return this != internal_default_instance() && predicates_ != nullptr;
}
inline void VectorANNS::clear_predicates() {
  if (GetArenaNoVirtual() == nullptr && predicates_ != nullptr) {
    delete predicates_;
  }
  predicates_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& VectorANNS::predicates() const {
  const ::milvus::proto::plan::Expr* p = predicates_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.predicates)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* VectorANNS::release_predicates() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.predicates)
  
  ::milvus::proto::plan::Expr* temp = predicates_;
  predicates_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* VectorANNS::mutable_predicates() {
  
  if (predicates_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    predicates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.predicates)
  return predicates_;
}
inline void VectorANNS::set_allocated_predicates(::milvus::proto::plan::Expr* predicates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete predicates_;
  }
  if (predicates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      predicates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicates, submessage_arena);
    }
    
  } else {
    
  }
  predicates_ = predicates;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.predicates)
}

// .milvus.proto.plan.QueryInfo query_info = 4;
inline bool VectorANNS::has_query_info() const {
  return this != internal_default_instance() && query_info_ != nullptr;
}
inline void VectorANNS::clear_query_info() {
  if (GetArenaNoVirtual() == nullptr && query_info_ != nullptr) {
    delete query_info_;
  }
  query_info_ = nullptr;
}
inline const ::milvus::proto::plan::QueryInfo& VectorANNS::query_info() const {
  const ::milvus::proto::plan::QueryInfo* p = query_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.query_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::QueryInfo*>(
      &::milvus::proto::plan::_QueryInfo_default_instance_);
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::release_query_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.query_info)
  
  ::milvus::proto::plan::QueryInfo* temp = query_info_;
  query_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::mutable_query_info() {
  
  if (query_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::QueryInfo>(GetArenaNoVirtual());
    query_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.query_info)
  return query_info_;
}
inline void VectorANNS::set_allocated_query_info(::milvus::proto::plan::QueryInfo* query_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete query_info_;
  }
  if (query_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_info, submessage_arena);
    }
    
  } else {
    
  }
  query_info_ = query_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.query_info)
}

// string placeholder_tag = 5;
inline void VectorANNS::clear_placeholder_tag() {
  placeholder_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VectorANNS::placeholder_tag() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.placeholder_tag)
  return placeholder_tag_.GetNoArena();
}
inline void VectorANNS::set_placeholder_tag(const std::string& value) {
  
  placeholder_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline void VectorANNS::set_placeholder_tag(std::string&& value) {
  
  placeholder_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline void VectorANNS::set_placeholder_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  placeholder_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline void VectorANNS::set_placeholder_tag(const char* value, size_t size) {
  
  placeholder_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline std::string* VectorANNS::mutable_placeholder_tag() {
  
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.placeholder_tag)
  return placeholder_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VectorANNS::release_placeholder_tag() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.placeholder_tag)
  
  return placeholder_tag_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VectorANNS::set_allocated_placeholder_tag(std::string* placeholder_tag) {
  if (placeholder_tag != nullptr) {
    
  } else {
    
  }
  placeholder_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), placeholder_tag);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.placeholder_tag)
}

// -------------------------------------------------------------------

// PlanNode

// .milvus.proto.plan.VectorANNS vector_anns = 1;
inline bool PlanNode::has_vector_anns() const {
  return node_case() == kVectorAnns;
}
inline void PlanNode::set_has_vector_anns() {
  _oneof_case_[0] = kVectorAnns;
}
inline void PlanNode::clear_vector_anns() {
  if (has_vector_anns()) {
    delete node_.vector_anns_;
    clear_has_node();
  }
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::release_vector_anns() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.PlanNode.vector_anns)
  if (has_vector_anns()) {
    clear_has_node();
      ::milvus::proto::plan::VectorANNS* temp = node_.vector_anns_;
    node_.vector_anns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::VectorANNS& PlanNode::vector_anns() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.vector_anns)
  return has_vector_anns()
      ? *node_.vector_anns_
      : *reinterpret_cast< ::milvus::proto::plan::VectorANNS*>(&::milvus::proto::plan::_VectorANNS_default_instance_);
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::mutable_vector_anns() {
  if (!has_vector_anns()) {
    clear_node();
    set_has_vector_anns();
    node_.vector_anns_ = CreateMaybeMessage< ::milvus::proto::plan::VectorANNS >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.PlanNode.vector_anns)
  return node_.vector_anns_;
}

// .milvus.proto.plan.Expr predicates = 2;
inline bool PlanNode::has_predicates() const {
  return node_case() == kPredicates;
}
inline void PlanNode::set_has_predicates() {
  _oneof_case_[0] = kPredicates;
}
inline void PlanNode::clear_predicates() {
  if (has_predicates()) {
    delete node_.predicates_;
    clear_has_node();
  }
}
inline ::milvus::proto::plan::Expr* PlanNode::release_predicates() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.PlanNode.predicates)
  if (has_predicates()) {
    clear_has_node();
      ::milvus::proto::plan::Expr* temp = node_.predicates_;
    node_.predicates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::Expr& PlanNode::predicates() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.predicates)
  return has_predicates()
      ? *node_.predicates_
      : *reinterpret_cast< ::milvus::proto::plan::Expr*>(&::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* PlanNode::mutable_predicates() {
  if (!has_predicates()) {
    clear_node();
    set_has_predicates();
    node_.predicates_ = CreateMaybeMessage< ::milvus::proto::plan::Expr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.PlanNode.predicates)
  return node_.predicates_;
}

// repeated int64 output_field_ids = 3;
inline int PlanNode::output_field_ids_size() const {
  return output_field_ids_.size();
}
inline void PlanNode::clear_output_field_ids() {
  output_field_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlanNode::output_field_ids(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.output_field_ids)
  return output_field_ids_.Get(index);
}
inline void PlanNode::set_output_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  output_field_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.PlanNode.output_field_ids)
}
inline void PlanNode::add_output_field_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  output_field_ids_.Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.plan.PlanNode.output_field_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlanNode::output_field_ids() const {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.PlanNode.output_field_ids)
  return output_field_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlanNode::mutable_output_field_ids() {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.PlanNode.output_field_ids)
  return &output_field_ids_;
}

inline bool PlanNode::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void PlanNode::clear_has_node() {
  _oneof_case_[0] = NODE_NOT_SET;
}
inline PlanNode::NodeCase PlanNode::node_case() const {
  return PlanNode::NodeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace plan
}  // namespace proto
}  // namespace milvus

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::milvus::proto::plan::UnaryExpr_UnaryOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::UnaryExpr_UnaryOp>() {
  return ::milvus::proto::plan::UnaryExpr_UnaryOp_descriptor();
}
template <> struct is_proto_enum< ::milvus::proto::plan::BinaryExpr_BinaryOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::BinaryExpr_BinaryOp>() {
  return ::milvus::proto::plan::BinaryExpr_BinaryOp_descriptor();
}
template <> struct is_proto_enum< ::milvus::proto::plan::OpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::OpType>() {
  return ::milvus::proto::plan::OpType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_plan_2eproto
